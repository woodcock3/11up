{"version":3,"file":"index.js","sources":["../../../node_modules/@fluss/core/is_promise.js","../../common/build/mkdir.js","../../common/build/pretty.js","../src/index.ts"],"sourcesContent":["const o=o=>o instanceof Promise;export{o as isPromise};\n//# sourceMappingURL=is_promise.js.map\n","import { dirname, extname } from 'path';\nimport { existsSync, promises } from 'fs';\nimport { pipe, when, identity } from '@fluss/core';\nimport { unit } from './unit.js';\nimport { resolve } from './promise.js';\n\n/** Checks if a path points to a directory. */\nconst isDirectory = (path) => extname(path) === '';\n\nconst mkdir = pipe(\n  when(isDirectory)(identity, dirname),\n  when(existsSync)(\n    pipe(resolve, unit),\n    pipe(\n      (directory) => promises.mkdir(directory, { recursive: true }),\n      unit,\n    ),\n  ),\n);\n\nexport { isDirectory, mkdir };\n","import chalk from 'chalk';\n\nlet pluginName = '';\n\n/** Defines name of plugin to distinguish logs in DEBUG mode. */\nconst definePluginName = (name) =>\n  void (pluginName = name);\n\n/** Convert Error to string. */\nconst errorToString = (error) =>\n  error.name + ': ' + error.message + '\\n' + error.stack;\n\n/**\n * Log _message_ bound with _name_ of the process\n * to terminal.\n *\n * @param paint - function that paint _message_.\n * @param message\n * @param emoji - just for fun :)\n */\nconst log = (paint, message, emoji) =>\n  console.info(\n    ' ' +\n      chalk.black.bgYellowBright(new Date().toLocaleTimeString()) +\n      ' -> ' +\n      chalk.bold.gray(pluginName) +\n      ': ' +\n      paint(message instanceof Error ? errorToString(message) : message) +\n      ' ' +\n      emoji,\n  );\n\n/**\n * Alert about starting of process.\n *\n * @param message\n */\nconst start = (message) => log(chalk.green, message, 'üÜô');\n\n/**\n * Alert about successful ending of process.\n *\n * @param message\n */\nconst done = (message) => log(chalk.magenta, message, 'üôå');\n\n/**\n * Alert about error that was occurred during process execution.\n *\n * @param message\n */\nconst oops = (message) => log(chalk.red, message, 'üí•');\n\n/** Shows warning message. */\nconst warn = (message) => log(chalk.blue, message, '‚ùóÔ∏è');\n\nconst bold = chalk.bold;\n\nexport { bold, definePluginName, done, oops, start, warn };\n","import { sep } from 'path';\n\nimport { definePluginName, isProduction } from '@eleventy-packages/common';\n\nimport { CompressAlgorithm } from './types';\nimport { compressHTMLWithLinks } from './compress_html_with_links';\n\nexport interface CompressPluginOptions {\n  enabled?: boolean;\n  algorithm?: CompressAlgorithm | ReadonlyArray<CompressAlgorithm>;\n}\n\ndefinePluginName('Icons');\n\n/** Build directory where Eleventy write templates. */\nlet buildDirectory: string;\n\n/**\n * Compress content with a specified `algorithm`.\n *\n * At current time available algorithms are:\n *\n *  - [`brotli`](https://brotli.org)\n *  - [`gzip`](http://www.gzip.org)\n *  - [`deflate`](https://en.wikipedia.org/wiki/Deflate)\n *\n * **This plugin should be added last to Eleventy.**\n */\nexport const compress = (\n  config: Record<string, Function>,\n  {\n    enabled = isProduction(),\n    algorithm = 'brotli',\n  }: CompressPluginOptions = {},\n) => {\n  if (enabled) {\n    config.addTransform(\n      'compress',\n      async (content: string, outputPath: string) => {\n        if (outputPath.endsWith('html')) {\n          // We can safely extract name of the build directory,\n          // because it is first directory in _outputPath_.\n          buildDirectory ??= outputPath.split(sep)[0];\n\n          await compressHTMLWithLinks(\n            content,\n            outputPath,\n            algorithm,\n            buildDirectory,\n          );\n        }\n\n        return content;\n      },\n    );\n  }\n};\n"],"names":[],"mappings":"0TAAA,+pBCOA,4HCLA,SAGA,mlDCUA"}