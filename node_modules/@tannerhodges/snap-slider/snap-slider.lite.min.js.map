{"version":3,"sources":["webpack://SnapSlider/webpack/universalModuleDefinition","webpack://SnapSlider/webpack/bootstrap","webpack://SnapSlider/./node_modules/lodash/isObject.js","webpack://SnapSlider/./node_modules/lodash/debounce.js","webpack://SnapSlider/./node_modules/lodash/throttle.js","webpack://SnapSlider/./node_modules/lodash/_root.js","webpack://SnapSlider/./node_modules/lodash/_Symbol.js","webpack://SnapSlider/./node_modules/smoothscroll-polyfill/dist/smoothscroll.js","webpack://SnapSlider/./node_modules/tabbable/index.js","webpack://SnapSlider/./node_modules/lodash/now.js","webpack://SnapSlider/./node_modules/lodash/_freeGlobal.js","webpack://SnapSlider/(webpack)/buildin/global.js","webpack://SnapSlider/./node_modules/lodash/toNumber.js","webpack://SnapSlider/./node_modules/lodash/_baseTrim.js","webpack://SnapSlider/./node_modules/lodash/_trimmedEndIndex.js","webpack://SnapSlider/./node_modules/lodash/isSymbol.js","webpack://SnapSlider/./node_modules/lodash/_baseGetTag.js","webpack://SnapSlider/./node_modules/lodash/_getRawTag.js","webpack://SnapSlider/./node_modules/lodash/_objectToString.js","webpack://SnapSlider/./node_modules/lodash/isObjectLike.js","webpack://SnapSlider/./node_modules/element-closest/index.mjs","webpack://SnapSlider/./src/helpers/toArray.js","webpack://SnapSlider/./src/helpers/qsa.js","webpack://SnapSlider/./src/helpers/getElements.js","webpack://SnapSlider/./src/helpers/hasOwnProperty.js","webpack://SnapSlider/./src/helpers/isObject.js","webpack://SnapSlider/./src/helpers/minmax.js","webpack://SnapSlider/./src/helpers/passive.js","webpack://SnapSlider/./src/helpers/pick.js","webpack://SnapSlider/./src/helpers/values.js","webpack://SnapSlider/./src/snap-slider.js","webpack://SnapSlider/./src/helpers/getStyle.js","webpack://SnapSlider/./src/helpers/getClosestAttribute.js","webpack://SnapSlider/./src/helpers/onReady.js","webpack://SnapSlider/./src/helpers/on.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","type","isObject","now","toNumber","nativeMax","Math","max","nativeMin","min","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","clearTimeout","cancel","flush","debounce","freeGlobal","freeSelf","self","Function","polyfill","w","document","documentElement","style","__forceSmoothScrollPolyfill__","userAgent","Element","HTMLElement","original","scroll","scrollTo","scrollBy","elementScroll","scrollElement","scrollIntoView","performance","Date","ROUNDING_TOLERANCE","navigator","RegExp","join","test","shouldBailOut","smoothScroll","body","left","scrollX","pageXOffset","top","scrollY","pageYOffset","scrollLeft","scrollTop","SyntaxError","behavior","scrollableParent","findScrollableParent","parentRects","getBoundingClientRect","clientRects","getComputedStyle","position","x","y","firstArg","hasScrollableSpace","el","axis","clientHeight","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","isScrollable","isScrollableY","isScrollableX","parentNode","host","step","context","currentX","currentY","k","elapsed","startTime","cos","PI","startX","startY","method","scrollable","requestAnimationFrame","candidateSelectors","candidateSelector","matches","msMatchesSelector","webkitMatchesSelector","tabbable","candidate","candidateTabindex","regularTabbables","orderedTabbables","candidates","querySelectorAll","includeContainer","Array","slice","unshift","length","isNodeMatchingSelectorTabbable","getTabindex","push","documentOrder","tabIndex","node","sort","sortOrderedTabbables","map","a","concat","isNodeMatchingSelectorFocusable","isInput","isRadio","checked","nodes","getCheckedRadio","ownerDocument","isTabbableRadio","isNonTabbableRadio","disabled","isHiddenInput","offsetParent","visibility","isHidden","isTabbable","Error","isFocusable","focusableCandidateSelector","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","b","tagName","global","g","e","baseTrim","isSymbol","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","other","valueOf","isBinary","trimmedEndIndex","reTrimStart","string","replace","reWhitespace","index","charAt","baseGetTag","isObjectLike","getRawTag","objectToString","symToStringTag","objectProto","nativeObjectToString","toString","isOwn","tag","unmasked","ElementPrototype","mozMatchesSelector","selector","elements","Boolean","closest","element","nodeType","toArray","val","qsa","getElements","obj","prop","constructor","minmax","passive","opts","addEventListener","removeEventListener","error","pick","keys","reduce","values","arr","counter","SnapSlider","containerOrOptions","terms","prev","next","callbacks","init","container","watchForChanges","_SnapSliders","id","indexOf","button","goto","split","str","trim","pop","sliderID","nav","slider","event","target","getButtonTarget","idOrElements","slides","buttons","start","loop","on","shift","eventName","getMaybeSetID","getMaybeSetSlides","align","getMaybeSetAlign","current","getMaybeSetStart","getMaybeSetLoop","transition","scrolling","navOptions","addGotoButtons","addNav","update","setAttribute","children","forEach","slide","isValidIndex","getStyle","attr","getClosestAttribute","getIndexNumber","num","ceil","getSnapAlign","offsetTop","offsetLeft","offsetHeight","offsetWidth","focus","force","ignoreCallbacks","immediate","getSlide","getScrollOffset","startTransition","fireEvent","buildGoto","from","to","diff","abs","stuck","checkTransition","stopTransition","match","textContent","toLowerCase","className","isRelative","buttonsOrOptions","hasAttribute","setGoto","nextIndex","isPrevButton","isNextButton","updateButtons","filter","getButtons","isCurrent","classList","add","remove","removeAttribute","tab","navContainers","navContainer","offset","scrollListener","throttle","getClosest","scrollEndListener","arrowKeyListener","defaultPrevented","isPrev","isNext","preventDefault","focusListener","contains","resizeObserver","observe","disconnect","ResizeObserver","resizeCallback","initialOptions","hasLoaded","updateSlides","handleFocus","events","callback","getCurrentSlide","preventScroll","activeElement","$","fn","snapSlider","readyState","onReady","elementClosest","smoothscroll","parentSelector","childSelector","parent","querySelector","possibleTargets","handleGoto"],"mappings":"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","file":"snap-slider.lite.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SnapSlider\"] = factory();\n\telse\n\t\troot[\"SnapSlider\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      while (el !== d.body && isScrollable(el) === false) {\n        el = el.parentNode || el.host;\n      }\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n","var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","function polyfill(window) {\n  var ElementPrototype = window.Element.prototype;\n\n  if (typeof ElementPrototype.matches !== 'function') {\n    ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.mozMatchesSelector || ElementPrototype.webkitMatchesSelector || function matches(selector) {\n      var element = this;\n      var elements = (element.document || element.ownerDocument).querySelectorAll(selector);\n      var index = 0;\n\n      while (elements[index] && elements[index] !== element) {\n        ++index;\n      }\n\n      return Boolean(elements[index]);\n    };\n  }\n\n  if (typeof ElementPrototype.closest !== 'function') {\n    ElementPrototype.closest = function closest(selector) {\n      var element = this;\n\n      while (element && element.nodeType === 1) {\n        if (element.matches(selector)) {\n          return element;\n        }\n\n        element = element.parentNode;\n      }\n\n      return null;\n    };\n  }\n}\n\nexport default polyfill;\n//# sourceMappingURL=index.mjs.map\n","/**\n * Convert a value to an array.\n * @param  {mixed}   val\n * @return {Array}\n */\nexport default function toArray(val) {\n  return Array.prototype.slice.call(val);\n}\n","import toArray from './toArray';\n\n/**\n * QSA = \"Query Selector All\" that returns an Array instead of a NodeList.\n * @param  {String}   selector\n * @param  {Element}  context\n * @return {Array}\n */\nexport default function qsa(selector, context) {\n  return selector ? toArray((context || document).querySelectorAll(selector)) : [];\n}\n","import qsa from './qsa';\n\n/**\n * Get an array of elements from a mixed-value parameter.\n * Accepts Strings, Elements, and Array-like values.\n * @param  {String|Element|Array}  elements\n * @param  {Element}  context\n * @return {Array}\n */\nexport default function getElements(elements, context) {\n  // 1. If value is a String, query the DOM\n  if (typeof elements === 'string') {\n    return qsa(elements, context);\n  }\n\n  // 2. Put single element in an Array\n  if (elements instanceof Element) {\n    return [elements];\n  }\n\n  // 3. Assume everything can be treated like an Array\n  if (elements) {\n    return Array.prototype.slice.call(elements);\n  }\n\n  // 4. Otherwise, fallback to an empty array\n  return [];\n}\n","/**\n * Check whether an object actually has a property.\n * @param  {Object} obj\n * @param  {String} prop\n * @return {Boolean}\n */\nexport default function hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","/**\n * Strict check for Objects. Literally checks whether\n * the value's constructor is \"Object\".\n * @param  {mixed}  val\n * @return {String}\n */\nexport default function isObject(val) {\n  return val && val.constructor.name === 'Object';\n}\n","/**\n * Keep a value within some minimum and maximum values.\n * @param  {Number}  value\n * @param  {Number}  min\n * @param  {Number}  max\n * @return {Number}\n */\nexport default function minmax(value, min, max) {\n  value = Math.min(max, value);\n  value = Math.max(min, value);\n  return value;\n}\n","/* eslint-disable getter-return */\n\n/**\n * Passive Event Listeners.\n *\n * Pass this value as a 3rd argument to your event listeners\n * to dramatically improve performance.\n *\n * @see https://developers.google.com/web/updates/2016/06/passive-event-listeners\n * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n * @type {Boolean}\n */\nconst passive = (() => {\n  let result = false;\n\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        result = { passive: true };\n      },\n    });\n    window.addEventListener('testPassive', null, opts);\n    window.removeEventListener('testPassive', null, opts);\n  } catch (error) {\n    // 🤫\n  }\n\n  return result;\n})();\n\nexport default passive;\n","/**\n * Pick keys from an object.\n * @param  {Object} obj\n * @param  {Array}  keys\n * @return {Object}\n */\nexport default function pick(obj, keys) {\n  return keys.reduce((result, key) => {\n    result[key] = obj[key];\n\n    return result;\n  }, {});\n}\n","/* eslint-disable no-restricted-syntax, no-var, vars-on-top */\n\nimport hasOwnProperty from './hasOwnProperty';\n\n/**\n * Helper that does the same thing as `Object.values()`. Works in IE!\n * @param  {Object}  obj\n * @return {Array}\n */\nfunction values(obj) {\n  var arr = [];\n\n  for (var prop in obj) {\n    if (hasOwnProperty(obj, prop)) {\n      arr.push(obj[prop]);\n    }\n  }\n\n  return arr;\n}\n\n// Use native code if supported, else return polyfill.\n// eslint-disable-next-line no-confusing-arrow\nconst fn = (() => typeof Object.values === 'function' ? Object.values : values)();\n\nexport default fn;\n","// Dependencies\nimport elementClosest from 'element-closest';\nimport smoothscroll from 'smoothscroll-polyfill';\nimport tabbable from 'tabbable';\n\n// Helpers\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nimport getClosestAttribute from './helpers/getClosestAttribute';\nimport getElements from './helpers/getElements';\nimport getStyle from './helpers/getStyle';\nimport hasOwnProperty from './helpers/hasOwnProperty';\nimport isObject from './helpers/isObject';\nimport minmax from './helpers/minmax';\nimport on from './helpers/on';\nimport onReady from './helpers/onReady';\nimport passive from './helpers/passive';\nimport pick from './helpers/pick';\nimport qsa from './helpers/qsa';\nimport toArray from './helpers/toArray';\nimport values from './helpers/values';\n\n// Modules\nconst logger = (process.env.NODE_ENV !== 'production')\n  ? require('./modules/logger')\n  : {};\n\n// Internal Variables\nlet counter = 1;\n\n/**\n * Snap Slider.\n * @class\n */\nclass SnapSlider {\n  /**\n   * New Snap Slider.\n   *\n   * See `init()` for a full breakdown of `options`.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @constructor\n   */\n  constructor(containerOrOptions, options = {}) {\n    // Setup internal variables.\n    this.terms = {\n      prev: /(prev|back|before|left|up)/,\n      next: /(next|forward|after|right|down)/,\n    };\n\n    /* eslint-disable quote-props */\n    this.callbacks = {\n      'load': [],\n      'change': [],\n      'change.click': [],\n      'change.scroll': [],\n      'change.keydown': [],\n      'change.focusin': [],\n      'scroll': [],\n      'scroll.start': [],\n      'scroll.end': [],\n    };\n    /* eslint-enable quote-props */\n\n    this.init(containerOrOptions, options);\n\n    // Don't construct sliders with empty containers.\n    if (!this.container) {\n      return;\n    }\n\n    this.watchForChanges();\n\n    // Keep track of the slider so we can reference & debug it later.\n    this.container.SnapSlider = this;\n    window._SnapSliders[this.id] = this;\n  }\n\n  /**\n   * Initialize this slider.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String}                       options.id\n   * @param  {String|Element|Array}         options.slides\n   * @param  {String|Number}                options.start\n   * @param  {String|Element|Array}         options.nav\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {void}\n   */\n  init(containerOrOptions, options = {}) {\n    // Allow people to quickly spin up sliders by just passing a container\n    // element, or by passing in a single options object.\n    if (isObject(containerOrOptions)) {\n      options = containerOrOptions;\n    }\n\n    // Fill default options.\n    this.options = {\n      container: containerOrOptions,\n      id: '',\n      slides: '',\n      nav: '',\n      buttons: '',\n      prev: '',\n      next: '',\n      start: 0,\n      loop: null,\n      on: {},\n      ...options,\n    };\n\n    // Get single element from params.\n    const container = getElements(this.options.container).shift();\n\n    // Don't construct sliders with empty containers.\n    if (!container) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n🚫 Whoops! Snap Slider can't find a container element matching \"${this.options.container}\".\\n\n🔍 Please check your selectors for typos. Make sure the element actually exists\n   in the DOM when Snap Slider tries to initialize it.\\n\n👇 Here's a copy of the options you tried to initialize with for debugging:\\n\\n`, this.options, '\\n\\n');\n      }\n      return;\n    }\n\n    // Great! Now let's start initializing everything.\n    this.container = container;\n\n    // Get selectors from JavaScript or data attributes.\n    this.options.buttons = options.buttons || this.container.getAttribute('data-snap-slider-buttons');\n    this.options.prev = options.prev || this.container.getAttribute('data-snap-slider-prev');\n    this.options.next = options.next || this.container.getAttribute('data-snap-slider-next');\n\n    // Get and set persistent options in data attributes.\n    this.id = this.getMaybeSetID(container, this.options.id);\n    this.slides = this.getMaybeSetSlides(container, this.options.slides);\n    this.align = this.getMaybeSetAlign(container, this.options.align);\n    this.current = this.getMaybeSetStart(container, this.options.start);\n    this.loop = this.getMaybeSetLoop(container, this.options.loop);\n\n    // Reset internal variables.\n    this.transition = null;\n    this.scrolling = false;\n\n    // Add custom callbacks.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const eventName in this.options.on) {\n      if (hasOwnProperty(this.options.on, eventName)) {\n        this.on(eventName, this.options.on[eventName]);\n      }\n    }\n\n    // Setup navigation.\n    // NOTE: If left blank, `addNav()` will handle the fallbacks for button selectors.\n    const navOptions = pick(this.options, [\n      'buttons',\n      'prev',\n      'next',\n    ]);\n\n    // Init custom goto buttons in the container.\n    // NOTE: \"Goto\" buttons are automatically handled by delegated click\n    // events on the `body`. For more details, see `handleGotoClick()`.\n    this.addGotoButtons({ ...navOptions, container });\n\n    // Init standard navs with data attributes.\n    this.addNav(`[data-snap-slider-nav=\"${this.id}\"]`, navOptions);\n\n    // Then init custom navs too.\n    if (this.options.nav) {\n      this.addNav(this.options.nav, navOptions);\n    }\n\n    // Go to the slide we want to start on.\n    this.update();\n  }\n\n  /**\n   * Get and maybe set a slider's ID on the closest container element.\n   *\n   * If no ID was specified, generates a fallback ID.\n   *\n   * @param  {Element}  container\n   * @param  {String}   id\n   * @return {String}\n   */\n  getMaybeSetID(container, id) {\n    // Either use the ID we were given or the ID already on the container.\n    id = id\n      || container.getAttribute('data-snap-slider')\n      || container.id;\n\n    // If we don't have an ID, make one up and increment our internal\n    // counter for the next slider.\n    if (!id) {\n      id = `slider-${counter}`;\n      counter += 1;\n    }\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider', id);\n\n    // Return the final ID.\n    return id;\n  }\n\n  /**\n   * Get all slide elements for a given container.\n   *\n   * Defaults to container's children.\n   *\n   * @param  {Element}  container\n   * @param  {String}   selector\n   * @return {Array}\n   */\n  getMaybeSetSlides(container, selector) {\n    // Get selector from JavaScript or data attribute.\n    selector = selector && typeof selector === 'string'\n      ? selector\n      : container.getAttribute('data-snap-slider-slides');\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-slides', selector || '');\n\n    // If selector exists, use those elements. Otherwise,\n    // assume the container's immediate children are slides.\n    const slides = selector\n      ? getElements(selector, container)\n      : toArray(container.children);\n\n    // Ensure all slides are focusable but not tabbable.\n    slides.forEach((slide) => slide.setAttribute('tabindex', '-1'));\n\n    // Return array of slides.\n    return slides;\n  }\n\n  /**\n   * Get alignment fallback for a given container.\n   *\n   * @param  {Element}  container\n   * @param  {String}   align\n   * @return {String}\n   */\n  getMaybeSetAlign(container, align) {\n    // Get align index from JavaScript, data attribute, or leave blank.\n    align = align || container.getAttribute('data-snap-slider-align') || '';\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-align', align);\n\n    return align;\n  }\n\n  /**\n   * Get start index for a given container.\n   *\n   * Defaults to 1.\n   *\n   * @param  {Element}  container\n   * @param  {String}   start\n   * @return {String|Number}\n   */\n  getMaybeSetStart(container, start) {\n    // Get start index from JavaScript, data attribute, or default to 1.\n    if (!SnapSlider.isValidIndex(start)) {\n      start = container.getAttribute('data-snap-slider-start') || 1;\n    }\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-start', start);\n\n    return start;\n  }\n\n  /**\n   * Get and maybe set a slider's `loop` option on the closest container element.\n   *\n   * @param  {Element}  container\n   * @param  {Boolean}  loop\n   * @return {String}\n   */\n  getMaybeSetLoop(container, loop) {\n    // If we were given a Boolean value to set, use that.\n    // Else check for an existing data attribute.\n    // Defaults to `false`.\n    loop = typeof loop === 'boolean'\n      ? loop\n      : container.getAttribute('data-snap-slider-loop') === 'true';\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-loop', loop);\n\n    // Return the final loop value.\n    return loop;\n  }\n\n  /**\n   * Get the `scroll-snap-align` for a snap slider element.\n   *\n   * Falls back to `data-snap-slider-align` when no CSS\n   * is detected, otherwise defaults to `start`.\n   *\n   * @param  {Element}  el\n   * @return {String}\n   */\n  getSnapAlign(el) {\n    // Get element's CSS align value.\n    const style = getStyle(el, 'scrollSnapAlign');\n\n    // If browser supports Scroll Snap and slide\n    // has a non-empty value, return it.\n    if (style && style.indexOf('none') < 0) {\n      return style;\n    }\n\n    // Otherwise, fallback to the slider's align attribute.\n    // Else assume \"start\" for everything.\n    return getClosestAttribute(el, 'data-snap-slider-align')\n      || 'start';\n  }\n\n  /**\n   * Get a specific slide element. Accepts any valid goto alias.\n   *\n   * @param  {Number}   index  Starts at 1.\n   * @return {Element}\n   */\n  getSlide(index) {\n    // Convert index aliases to numbers.\n    index = this.getIndexNumber(index);\n\n    // Return the slide for that numeric index.\n    // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n    return this.slides[index - 1];\n  }\n\n  /**\n   * Get the current slide element.\n   *\n   * @return {Element}\n   */\n  getCurrentSlide() {\n    // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n    return this.slides[this.current - 1];\n  }\n\n  /**\n   * Is this a valid index?\n   *\n   * - first\n   * - middle\n   * - last\n   * - prev\n   * - next\n   *\n   * @param  {String|Number}  index\n   * @return {Number}\n   */\n  static isValidIndex(index) {\n    const aliases = [\n      'first',\n      'middle',\n      'last',\n      'prev',\n      'next',\n    ];\n\n    // Valid indexes are either a known alias,\n    // or a positive integer.\n    return aliases.indexOf(index) >= 0\n      || parseInt(index, 10) >= 1;\n  }\n\n  /**\n   * Get the slide number for any index.\n   *\n   * Returns -1 if index is invalid.\n   *\n   * @param  {String|Number}  index\n   * @return {Number}\n   */\n  getIndexNumber(index) {\n    let num;\n\n    if (index === 'first') {\n      // Get the first slide.\n      num = 1;\n    } else if (index === 'middle') {\n      // Get the middle slide.\n      num = Math.ceil(this.slides.length / 2);\n    } else if (index === 'last') {\n      // Get the last slide.\n      num = this.slides.length;\n    } else if (index === 'prev') {\n      // Get the previous slide.\n      num = this.current - 1;\n    } else if (index === 'next') {\n      // Get the next slide.\n      num = this.current + 1;\n    } else {\n      // Try to get a number.\n      num = parseInt(index, 10) || -1;\n    }\n\n    if (this.loop) {\n      // If we're looping, send out-of-bounds requests\n      // to the other end of the slider.\n      if (num < 1) {\n        num = this.slides.length;\n      }\n\n      if (num > this.slides.length) {\n        num = 1;\n      }\n    } else if (num < 1 || num > this.slides.length) {\n      // Otherwise, ignore out-of-range indexes.\n      num = -1;\n    }\n\n    // Return numeric index. Or, if something goes wrong,\n    // fallback to the first slide.\n    return num || 1;\n  }\n\n  /**\n   * Get the offset we should scroll to for a specific slide.\n   *\n   * @param  {Element}  slide\n   * @return {Object}   { top, left }\n   */\n  getScrollOffset(slide) {\n    const { container } = this;\n    const align = this.getSnapAlign(slide);\n\n    // Calculate the 'start' position by default.\n    // NOTE: This forces slides with align `none` to still snap into place.\n    let top = slide.offsetTop;\n    let left = slide.offsetLeft;\n\n    // NOTE: Because Safari uses the 2-value syntax, we simply check for matching\n    // keywords. If this causes incorrect behavior, use the `data-snap-slider-align`\n    // attribute to override our automatic CSS detection.\n    if (align.indexOf('center') >= 0) {\n      // To center a slide, start with its beginning offset (the 'start' position).\n      // Then add half the slide's size minus half the container size.\n      top = slide.offsetTop + slide.offsetHeight / 2 - container.offsetHeight / 2;\n      left = slide.offsetLeft + slide.offsetWidth / 2 - container.offsetWidth / 2;\n    } else if (align.indexOf('end') >= 0) {\n      // To align the end of a slide, start with its beginning offset (the 'start' position).\n      // Then subtract the size of the container, but add back the size of the slide.\n      top = slide.offsetTop - container.offsetHeight + slide.offsetHeight;\n      left = slide.offsetLeft - container.offsetWidth + slide.offsetWidth;\n    }\n\n    // Keep offsets within the scrollable area.\n    top = minmax(top, 0, container.scrollHeight);\n    left = minmax(left, 0, container.scrollWidth);\n\n    return { top, left };\n  }\n\n  /**\n   * Go to a slide.\n   *\n   * @param  {String|Number}  index                    Starts at 1.\n   * @param  {Object}         options\n   * @param  {Boolean}        options.focus\n   * @param  {Boolean}        options.force\n   * @param  {Boolean}        options.ignoreCallbacks\n   * @param  {Boolean}        options.immediate\n   * @param  {Event}          event\n   * @return {Boolean}\n   */\n  goto(index, options = {}, event) {\n    // Fill default options.\n    options = {\n      // By default, focus the slide we're going to.\n      focus: true,\n      // Force-update the scroll position, even if we're already on the current slide.\n      force: false,\n      // Ignore custom callbacks for events.\n      ignoreCallbacks: false,\n      // Immediately update position without smooth scrolling.\n      immediate: false,\n      ...options,\n    };\n\n    // Get the next slide we should go to.\n    const next = this.getIndexNumber(index);\n\n    // If nothing changed, don't do anything (as long as\n    // we're not trying to force it).\n    if (!options.force && next === this.current) {\n      return false;\n    }\n\n    // Get the next slide.\n    const slide = this.getSlide(next);\n\n    if (!slide) {\n      return false;\n    }\n\n    // Scroll to it!\n    const { top, left } = this.getScrollOffset(slide);\n\n    if (options.immediate) {\n      // Scroll immediately.\n      this.container.scroll({ top, left });\n    } else {\n      // Let the event handlers know we're coming, then smooth scroll.\n      this.startTransition(next);\n      this.container.scroll({ top, left, behavior: 'smooth' });\n    }\n\n    // Update state.\n    this.current = next;\n\n    // We changed slides!\n    this.fireEvent('change', event, options);\n\n    return true;\n  }\n\n  /**\n   * Build the `goto` attribute for a nav button.\n   *\n   * @param  {Element|Boolean}  nav\n   * @param  {String|Number}    index\n   * @return {String}\n   */\n  buildGoto(nav, index = '') {\n    // Start with an empty string.\n    let goto = '';\n\n    // If this button isn't part of a nav, include the slider ID.\n    if (!nav) {\n      goto += `${this.id}:`;\n    }\n\n    // Add the index and return.\n    return goto + index;\n  }\n\n  /**\n   * Set the `goto` attribute for nav buttons.\n   *\n   * @param  {String|Element|Array}  buttons\n   * @param  {String}                index\n   * @return {void}\n   */\n  setGoto(buttons, index) {\n    buttons = getElements(buttons);\n\n    // If we found custom prev/next buttons, set their `goto` attributes\n    // before we loop through the rest of the buttons.\n    buttons.forEach((button) => {\n      button.setAttribute('data-snap-slider-goto', this.buildGoto(\n        // Don't assume this button is grouped with the others. It may\n        // be somewhere else on the page, so double check for a parent\n        // slider or nav container.\n        button.closest('[data-snap-slider], [data-snap-slider-nav]'),\n        index,\n      ));\n    });\n  }\n\n  /**\n   * Get the slider ID and slide index a goto button is targeting.\n   *\n   * NOTE: This method is static so we can call it in the delegated body\n   * click events. For more details, see `handleGotoClick()`.\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Object}                { sliderID, index }\n   */\n  static getButtonTarget(button) {\n    // Where are we going?\n    const goto = button ? button.getAttribute('data-snap-slider-goto') : '';\n\n    // Ignore missing buttons and attributes.\n    if (!goto) {\n      return {};\n    }\n\n    // Parse slide index and slider ID from `goto` attribute.\n    const args = goto.split(':').map((str) => str.trim());\n    const index = args.pop();\n    let sliderID = args.pop();\n\n    // If the slider ID wasn't included, check for a parent nav or container element.\n    if (!sliderID) {\n      const nav = button.closest('[data-snap-slider-nav]');\n      const container = button.closest('[data-snap-slider]');\n\n      // If it is in a nav or container, get the slider ID from there.\n      if (nav) {\n        sliderID = nav.getAttribute('data-snap-slider-nav');\n      }\n\n      if (container) {\n        sliderID = container.getAttribute('data-snap-slider');\n      }\n    }\n\n    // If there's still no slider ID, is this button already in a slider?\n    if (!sliderID) {\n      const slider = button.closest('data-snap-slider');\n\n      // If it is in a slider, get the slider ID from there.\n      if (slider) {\n        sliderID = slider.getAttribute('data-snap-slider');\n      }\n    }\n\n    return { sliderID, index };\n  }\n\n  /**\n   * Handle click events for nav (aka \"goto\") buttons.\n   *\n   * By delegating events to the body, we can automatically\n   * handle dynamic goto buttons (i.e., without having to\n   * reinitialize slider events).\n   *\n   * @param  {Event}  event\n   * @return {void}\n   */\n  static handleGoto(event) {\n    // Get the button we clicked.\n    const button = event.target.closest('[data-snap-slider-goto]');\n\n    // Get the slider we're trying to update.\n    const { sliderID, index } = SnapSlider.getButtonTarget(button);\n    const slider = window._SnapSliders[sliderID];\n\n    // Make sure it actually exists.\n    if (!slider) {\n      return;\n    }\n\n    // Go! But only focus the slide if we're NOT clicking a prev/next button.\n    slider.goto(index, null, event);\n  }\n\n  /**\n   * Start transitioning to another slide.\n   *\n   * This way when you click a nav button, the current slide updates\n   * immediately but the scroll listener doesn't override it, or fire\n   * extra change events.\n   *\n   * @param  {Number}  next\n   * @return {void}\n   */\n  startTransition(next) {\n    // Tell the scroll listener which slide we're transitioning to.\n    this.transition = {\n      from: this.current,\n      to: next,\n      diff: Math.abs(next - this.current),\n    };\n\n    // In case someone's fast enough to start scrolling again before our\n    // scroll listener resolves the `transition` flag, or if the slide's\n    // already visible and nothing actually has to scroll,\n    // set a timeout to resolve the transition.\n    const stuck = this.transition.to;\n\n    // If there's already a check waiting, clear it to avoid accidentally\n    // reverting to the wrong slide.\n    if (this.checkTransition) {\n      clearTimeout(this.checkTransition);\n    }\n\n    // Now make sure we don't get stuck!\n    this.checkTransition = setTimeout(() => {\n      if (this.transition.to === stuck) {\n        this.stopTransition();\n      }\n    }, 1000);\n  }\n\n  /**\n   * Stop the transitions! Set things back to normal.\n   *\n   * @return {void}\n   */\n  stopTransition() {\n    // Clear transition checks.\n    this.transition = null;\n    clearTimeout(this.checkTransition);\n  }\n\n  /**\n   * Is this a \"previous\" button?\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Boolean}\n   */\n  isPrevButton(button) {\n    button = getElements(button).shift();\n\n    // Ignore missing elements.\n    if (!button) {\n      return false;\n    }\n\n    // Check whether the `goto` attribute is \"prev\".\n    // If not, check the text & class for common \"prev\" terms.\n    return (button.getAttribute('data-snap-slider-goto') || '').match(/\\bprev$/)\n      || button.textContent.toLowerCase().match(this.terms.prev)\n      || button.className.toLowerCase().match(this.terms.prev);\n  }\n\n  /**\n   * Is this a \"next\" button?\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Boolean}\n   */\n  isNextButton(button) {\n    button = getElements(button).shift();\n\n    // Ignore missing elements.\n    if (!button) {\n      return false;\n    }\n\n    // Check whether the `goto` attribute is \"next\".\n    // If not, check the text & class for common \"next\" terms.\n    return (button.getAttribute('data-snap-slider-goto') || '').match(/\\bnext$/)\n      || button.textContent.toLowerCase().match(this.terms.next)\n      || button.className.toLowerCase().match(this.terms.next);\n  }\n\n  /**\n   * Is this index a relative term? I.e., is it `prev` or `next`?\n   *\n   * @param  {String|Number}  index\n   * @return {Boolean}\n   */\n  static isRelative(index) {\n    return index === 'prev' || index === 'next';\n  }\n\n  /**\n   * Does an index match the current slide?\n   *\n   * @param  {String|Number}  index\n   * @return {Boolean}\n   */\n  isCurrent(index) {\n    // Ignore relative indexes (i.e., `prev` and `next`) since they\n    // always refer to one more or less than the current index.\n    if (SnapSlider.isRelative(index)) {\n      return false;\n    }\n\n    // Does this numeric index match the current slide?\n    return this.getIndexNumber(index) === this.current;\n  }\n\n  /**\n   * Add goto buttons for the current slider.\n   *\n   * @param  {String|Element|Array|Object}  buttonsOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {Boolean}\n   */\n  addGotoButtons(buttonsOrOptions, options = {}) {\n    // Allow people to quickly add nav buttons by just passing the\n    // selector, or by passing in a single options object.\n    if (isObject(buttonsOrOptions)) {\n      options = buttonsOrOptions;\n    }\n\n    // Fill default options.\n    options = {\n      container: '',\n      buttons: buttonsOrOptions,\n      prev: '',\n      next: '',\n      ...options,\n    };\n\n    // Get button elements.\n    // NOTE: If someone passes an overly-generic selector (e.g., `button`)\n    // this will query the entire document. In general, you should either\n    // specify a container element, use specific selectors, or pass\n    // the elements directly.\n    const buttons = getElements(options.buttons, options.container);\n    const prev = getElements(options.prev, options.container);\n    const next = getElements(options.next, options.container);\n\n    // If we found custom prev/next buttons, set their `goto` attributes\n    // before we loop through the rest of the buttons.\n    prev.forEach((b) => b.hasAttribute('data-snap-slider-goto') || this.setGoto(prev, 'prev'));\n    next.forEach((b) => b.hasAttribute('data-snap-slider-goto') || this.setGoto(next, 'next'));\n\n    // Keep track of the index outside of the loop so we can\n    // skip prev/next buttons but still go in order.\n    let nextIndex = 1;\n\n    // Loop through the buttons and set each one's `goto` attribute.\n    buttons.forEach((button) => {\n      // Ignore buttons that already have a `goto` attribute.\n      if (button.hasAttribute('data-snap-slider-goto')) {\n        return null;\n      }\n\n      // Previous\n      if (this.isPrevButton(button)) {\n        return this.setGoto(button, 'prev');\n      }\n\n      // Next\n      if (this.isNextButton(button)) {\n        return this.setGoto(button, 'next');\n      }\n\n      // Numeric: Check the text for a number, else fallback to the next index.\n      const index = parseInt(button.textContent.replace(/.*\\b(\\d+)\\b.*/, '$1'), 10) || nextIndex;\n\n      // Increment the next index.\n      nextIndex = index + 1;\n\n      return this.setGoto(button, index);\n    });\n\n    this.updateButtons();\n\n    return true;\n  }\n\n  /**\n   * Get navs for the current slider.\n   *\n   * @return {Array}\n   */\n  getNavs() {\n    // eslint-disable-next-line arrow-body-style\n    return qsa('[data-snap-slider-nav]').filter((nav) => {\n      // Only return navs targeting the current slider.\n      return nav.getAttribute('data-snap-slider-nav') === this.id;\n    });\n  }\n\n  /**\n   * Get nav buttons for the current slider.\n   *\n   * @return {Array}\n   */\n  getButtons() {\n    return qsa('[data-snap-slider-goto]').filter((button) => {\n      const { sliderID } = SnapSlider.getButtonTarget(button);\n      // Only return buttons targeting the current slider.\n      return sliderID === this.id;\n    });\n  }\n\n  /**\n   * Update nav buttons for the current slider.\n   *\n   * @return {void}\n   */\n  updateButtons() {\n    // Wait until the slider has initialized.\n    if (!this.current) {\n      return;\n    }\n\n    // Loop through all the nav buttons.\n    this.getButtons().forEach((button) => {\n      // Figure out which slide it's for...\n      const { index } = SnapSlider.getButtonTarget(button);\n\n      // And update its class.\n      if (this.isCurrent(index)) {\n        button.classList.add('is-current');\n      } else {\n        button.classList.remove('is-current');\n      }\n\n      // Also, enable/disable relative buttons unless `loop` is on.\n      if (!this.loop && SnapSlider.isRelative(index)) {\n        // Disable prev button on first slide.\n        // Disable next button on last slide.\n        const disabled = (index === 'prev' && this.current === 1)\n          || (index === 'next' && this.current === this.slides.length);\n\n        if (disabled) {\n          // button.setAttribute('disabled', '');\n          button.classList.add('is-disabled');\n        } else {\n          // button.removeAttribute('disabled', '');\n          button.classList.remove('is-disabled');\n        }\n      }\n    });\n  }\n\n  /**\n   * Update slide active states when the slider changes.\n   *\n   * @return {void}\n   */\n  updateSlides() {\n    this.slides.forEach((slide, index) => {\n      // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n      if (index === this.current - 1) {\n        slide.classList.add('is-current');\n        slide.removeAttribute('aria-hidden');\n\n        // Enable tabbing for current slide\n        qsa('[data-snap-slider-tabindex]', slide).forEach((tab) => {\n          tab.removeAttribute('tabindex');\n        });\n      } else {\n        slide.classList.remove('is-current');\n        slide.setAttribute('aria-hidden', 'true');\n\n        // Disable tabbing for non-current slides\n        tabbable(slide).forEach((tab) => {\n          tab.setAttribute('tabindex', '-1');\n          tab.setAttribute('data-snap-slider-tabindex', '');\n        });\n      }\n    });\n  }\n\n  /**\n   * Add a nav element for the current slider. Automatically hooks up any nav\n   * buttons inside the nav.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {Boolean}\n   */\n  addNav(containerOrOptions, options = {}) {\n    // Allow people to quickly add a nav by just passing a container\n    // element, or by passing in a single options object.\n    if (isObject(containerOrOptions)) {\n      options = containerOrOptions;\n    }\n\n    // Fill default options.\n    options = {\n      container: containerOrOptions,\n      buttons: '',\n      prev: '',\n      next: '',\n      ...options,\n    };\n\n    // Get matching nav containers.\n    const navContainers = getElements(options.container);\n\n    // Don't add navs without container elements.\n    if (!navContainers.length) {\n      return false;\n    }\n\n    navContainers.forEach((navContainer) => {\n      // Set a data attribute assigning the nav to this slider.\n      navContainer.setAttribute('data-snap-slider-nav', this.id);\n\n      // Get button selectors from JavaScript, data attribute, or default to 'button'.\n      // NOTE: In this case, allow the nav's data attribute to override the parent\n      // container's options.\n      const buttons = navContainer.getAttribute('data-snap-slider-buttons')\n        || options.buttons\n        || 'button';\n      const prev = options.prev || navContainer.getAttribute('data-snap-slider-prev');\n      const next = options.next || navContainer.getAttribute('data-snap-slider-next');\n\n      // And add them.\n      this.addGotoButtons({\n        container: navContainer,\n        buttons,\n        prev,\n        next,\n      });\n    });\n\n    return true;\n  }\n\n  /**\n   * Which slide is closest to its active offset position?\n   *\n   * Returns an object include the slide's index, element,\n   * and the diff between its active offset and our\n   * current scroll position.\n   *\n   * @return {Object}  { index, slide, diff }\n   */\n  getClosest() {\n    return this.slides.reduce((prev, slide, index) => {\n      // 1-index to stay consistent with our API.\n      index += 1;\n\n      // How far away are we from the next slide's active offset position?\n      const offset = this.getScrollOffset(slide);\n      const diff = {\n        top: Math.abs(this.container.scrollTop - offset.top),\n        left: Math.abs(this.container.scrollLeft - offset.left),\n      };\n\n      // Save the next slide's info to compare with other slides.\n      const next = { index, slide, diff };\n\n      // If this is the first slide, return it and compare the next one.\n      if (!prev) {\n        return next;\n      }\n\n      // Compare each slide to see which one is the closest to its active offset position.\n      // As soon as the next slide is at least as close as the previous one, return it.\n      if (next.diff.left <= prev.diff.left && next.diff.top <= prev.diff.top) {\n        return next;\n      }\n\n      // Otherwise, keep the last closest slide.\n      return prev;\n    // Init with `false` so the first slide gets processed just like the rest of them.\n    }, false);\n  }\n\n  /**\n   * Watch the container scroll for when the current slide changes.\n   *\n   * @return {void}\n   */\n  watchForChanges() {\n    // Scroll listener. Save so we can remove it during `destroy()`.\n    this.scrollListener = throttle((event) => {\n      // Which slide is closest to their active offset position?\n      const closest = this.getClosest();\n\n      // If someone's passively scrolling (i.e., not in a transition),\n      // then  as soon as we've scrolled to another slide, mark that\n      // slide as the new current one and fire a change event.\n      if (!this.transition && closest.index !== this.current) {\n        this.current = closest.index;\n        this.fireEvent('change', event);\n      }\n\n      // If we just started scrolling, update state and\n      // fire a `scroll.start` event.\n      if (!this.scrolling) {\n        this.scrolling = true;\n        this.fireEvent('scroll.start', event);\n      }\n\n      // Fire a generic `scroll` event.\n      this.fireEvent('scroll', event);\n    }, 250);\n\n    // Scroll end listener. Save so we can remove it during `destroy()`.\n    this.scrollEndListener = debounce((event) => {\n      // We're done scrolling!\n      this.scrolling = false;\n      this.fireEvent('scroll.end', event);\n\n      // Clear any previous transition checks.\n      // NOTE: This has to happen *after* we fire the `scroll.end` event,\n      // otherwise `handleFocus` won't be able to access `this.transition`.\n      this.stopTransition();\n    }, 250);\n\n    // Arrow key listener. Save so we can remove it during `destroy()`.\n    this.arrowKeyListener = throttle((event) => {\n      // Ignore events that have already been prevented.\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      // Listen for arrow keys.\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n      const isPrev = ['Up', 'ArrowUp', 'Left', 'ArrowLeft'].indexOf(event.key) >= 0;\n      const isNext = ['Down', 'ArrowDown', 'Right', 'ArrowRight'].indexOf(event.key) >= 0;\n\n      // Ignore non-arrow keys.\n      if (!isPrev && !isNext) {\n        return;\n      }\n\n      // Go to the next or previous slide.\n      this.goto(isNext ? 'next' : 'prev', null, event);\n\n      // Prevent default browser scroll.\n      event.preventDefault();\n    }, 250);\n\n    // Focus listener. Save so we can remove it during `destroy()`.\n    this.focusListener = (event) => {\n      // Only trigger `goto` on focus when we're not passively scrolling.\n      // However, if someone manually triggered a transition then\n      // allow them to click or tab away to a different slide.\n      if (this.scrolling && !this.transition) {\n        return;\n      }\n\n      // Get slide + index.\n      let slide;\n      let index;\n\n      this.slides.forEach((s, i) => {\n        if (s.contains(event.target)) {\n          slide = s;\n          index = i + 1;\n        }\n      }, null);\n\n      // If there's a matching slide, go to it.\n      if (slide) {\n        this.goto(index, null, event);\n      }\n    };\n\n    // Resize Observer. Save so we can disconnect it during `destroy()`.\n    // Only init if browser supports it, else fallback to noop.\n    this.resizeObserver = { observe: () => {}, disconnect: () => {} };\n    if ('ResizeObserver' in window) {\n      this.resizeObserver = new ResizeObserver(this.resizeCallback.bind(this));\n    }\n\n    // Add all our listeners.\n    // Set timeout to avoid initial `goto` event triggering a scroll listener.\n    setTimeout(() => {\n      this.container.addEventListener('scroll', this.scrollListener, passive);\n      this.container.addEventListener('scroll', this.scrollEndListener, passive);\n      this.container.addEventListener('keydown', this.arrowKeyListener);\n      this.container.addEventListener('focusin', this.focusListener);\n      this.resizeObserver.observe(this.container);\n\n      // Done loading!\n      this.fireEvent('load');\n    }, 100);\n  }\n\n  /**\n   * Update the slider on load.\n   *\n   * @return {void}\n   */\n  hasLoaded() {\n    this.container.classList.add('has-loaded');\n  }\n\n  /**\n   * Update this slider (e.g., on resize). Basically just repositions the\n   * current slide.\n   *\n   * @return {void}\n   */\n  update() {\n    // Make sure we're still on the current slide.\n    this.goto(this.current, {\n      focus: false,\n      force: true,\n      ignoreCallbacks: true,\n      immediate: true,\n    });\n  }\n\n  /**\n   * Destroy this slider. Stop any active transitions, remove its event\n   * listeners, and delete it from our internal array of slider instances.\n   *\n   * @return {void}\n   */\n  destroy() {\n    // Stop running transitions, event listeners, etc.\n    this.stopTransition();\n    this.container.removeEventListener('scroll', this.scrollListener);\n    this.container.removeEventListener('scroll', this.scrollEndListener);\n    this.container.removeEventListener('keydown', this.arrowKeyListener);\n    this.resizeObserver.disconnect();\n\n    // Reset callbacks.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const eventName in this.callbacks) {\n      if (hasOwnProperty(this.callbacks, eventName)) {\n        this.callbacks[eventName] = [];\n      }\n    }\n\n    // Remove references to this slider.\n    delete this.container.SnapSlider;\n    delete window._SnapSliders[this.id];\n  }\n\n  /**\n   * Reset this slider (e.g., after adding or removing a slide).\n   *\n   * See `init()` for a full breakdown of `options`.\n   *\n   * @param  {Object}  options\n   * @return {void}\n   */\n  reset(options = {}) {\n    // Copy initial options.\n    const initialOptions = this.options;\n\n    // Remove initial callbacks to avoid duplicating them.\n    delete initialOptions.on;\n\n    // Don't let people reset critical options during reset (e.g., slider ID).\n    delete options.container;\n    delete options.id;\n\n    // Re-initialize this slider with initial options + overrides.\n    this.init(this.container, { ...initialOptions, ...options });\n  }\n\n  /**\n   * Handle resize observer events.\n   *\n   * @return {void}\n   */\n  resizeCallback() {\n    this.update();\n  }\n\n  /**\n   * When an event happens, fire all the callback functions for that event.\n   *\n   * @param  {String}   eventName\n   * @param  {Event}    event\n   * @param  {Object}   options\n   * @param  {Boolean}  options.focus\n   * @param  {Boolean}  options.ignoreCallbacks\n   * @return {void}\n   */\n  fireEvent(eventName, event, options = {}) {\n    // Ignore invalid events.\n    if (!hasOwnProperty(this.callbacks, eventName)) {\n      return;\n    }\n\n    // Fill default options.\n    options = {\n      // By default, focus the slide we're going to.\n      focus: true,\n      // Ignore custom callbacks for events.\n      ignoreCallbacks: false,\n      ...options,\n    };\n\n    // Required: Update slider attributes on load.\n    if (eventName === 'load') {\n      this.hasLoaded();\n    }\n\n    // Required: Update buttons and slides on every change.\n    if (eventName === 'change') {\n      this.updateButtons();\n      this.updateSlides();\n    }\n\n    // Allow focus events to be ignored.\n    if (options.focus) {\n      this.handleFocus(eventName, event);\n    }\n\n    // Allow callbacks to be ignored.\n    if (options.ignoreCallbacks) {\n      return;\n    }\n\n    // Fallback object for `null` events.\n    event = event || {};\n\n    // Include more granular event types for easier callbacks.\n    const events = [eventName];\n\n    if (hasOwnProperty(this.callbacks, `${eventName}.${event.type}`)) {\n      events.push(`${eventName}.${event.type}`);\n    }\n\n    // Fire all the callbacks for each event.\n    events.forEach((name) => {\n      this.callbacks[name].forEach((callback) => {\n        if (typeof callback === 'function') {\n          callback(this, event);\n        }\n      });\n    });\n  }\n\n  /**\n   * Handle focus events differently depending on whether we're manually\n   * triggering changes or passively scrolling.\n   *\n   * @param  {String}   eventName\n   * @param  {Event}    event\n   * @return {void}\n   */\n  handleFocus(eventName, event) {\n    // Only handle focus for manually triggered changes (e.g., clicks and key presses).\n    // Ignore passive scrolling to avoid mistakenly hijacking someone's focus.\n    if (!this.transition) {\n      return;\n    }\n\n    // Only focus the slide if we're NOT clicking a prev/next button.\n    if (event && eventName === 'change') {\n      // Did we click a button?\n      const button = event.target.closest('[data-snap-slider-goto]');\n      const { index } = SnapSlider.getButtonTarget(button);\n\n      // If we clicked a relative button, get out.\n      if (SnapSlider.isRelative(index)) {\n        return;\n      }\n    }\n\n    // If we're only transitioning one slide over, focus immediately on change.\n    if (this.transition.diff <= 1 && eventName === 'change') {\n      this.getCurrentSlide().focus({ preventScroll: true });\n    }\n\n    // If we're transitioning across multiple slides, wait until the scroll ends to focus.\n    // Otherwise, we'll cause the scroll to flicker.\n    if (this.transition.diff > 1 && eventName === 'scroll.end') {\n      // Only focus the slide if we haven't already focused on another\n      // element during the transition.\n      if (!document.activeElement\n        || document.activeElement === document.body\n        || document.activeElement.closest('[data-snap-slider-goto]')) {\n        this.getCurrentSlide().focus({ preventScroll: true });\n      }\n    }\n  }\n\n  /**\n   * Add callbacks to fire on specific events.\n   *\n   * @param  {String}    event     Event name.\n   * @param  {Function}  callback  Function w/ slider and event params (e.g., `fn(slider, event)`).\n   * @return {void}\n   */\n  on(event, callback) {\n    // Ignore invalid events.\n    if (!hasOwnProperty(this.callbacks, event)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n🚫 Whoops! Snap Slider can't add events for \"${event}\".\\n\n📝 Please make sure your event matches one of the ones in this list:\\n\\n`, Object.keys(this.callbacks), '\\n\\n');\n      }\n      return;\n    }\n\n    // Ignore invalid callbacks.\n    if (typeof callback !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n  🚫 Whoops! Snap Slider can only add functions as callbacks.\\n\n  👀 It looks like you passed a \"${typeof callback}\" instead.\\n\\n`, callback, '\\n\\n');\n      }\n      return;\n    }\n\n    // Add the callback for our event.\n    this.callbacks[event].push(callback);\n  }\n\n  /**\n   * Log that we couldn't find the element you're looking for.\n   *\n   * @param  {mixed}  element\n   * @return {void}\n   */\n  static notFound(element) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(`\n😢 Oh no! Snap Slider couldn't find a slider for \"${element}\".\\n\n-------------------------------------------------------------------------------------------\nℹ️ NOTE: Make sure the elements you're trying to debug have a \\`data-snap-slider\\` attribute.\n-------------------------------------------------------------------------------------------\\n\\n`);\n    }\n  }\n\n  /**\n   * Get the `SnapSlider` object for a slider based on its ID.\n   *\n   * @param  {String}      id\n   * @return {SnapSlider}\n   */\n  static get(id) {\n    return window._SnapSliders[id];\n  }\n\n  /**\n   * `console.log` info about a slider, its nav, or goto buttons.\n   *\n   * @param  {String|Element|Array} idOrElements\n   * @return {void}\n   */\n  static debug(idOrElements) {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-irregular-whitespace */\n      let elements = [];\n\n      // 1. Debug all sliders by default.\n      if (arguments.length === 0) {\n        idOrElements = '[data-snap-slider]';\n      }\n\n      // 2. Debug a slider by its ID.\n      if (typeof idOrElements === 'string'\n        && hasOwnProperty(window._SnapSliders, idOrElements)) {\n        idOrElements = `[data-snap-slider=\"${idOrElements}\"]`;\n      }\n\n      // 3. Debug slider elements.\n      elements = getElements(idOrElements);\n\n      if (!elements.length) {\n        SnapSlider.notFound(idOrElements);\n        return;\n      }\n\n      // Debug all the things!\n      elements.forEach((el, i) => {\n        // What are we debugging? Is this a button, nav, or container?\n        const button = el.closest('[data-snap-slider-goto]');\n        const nav = el.closest('[data-snap-slider-nav]');\n        const container = el.closest('[data-snap-slider]');\n\n        // If we're debugging more than one element at a time,\n        // add the index # to each section heading.\n        const num = elements.length > 1 ? `#${i + 1} ` : '';\n\n        // 2a. Buttons\n        if (button) {\n          // Get details for the target slider & slide.\n          const target = SnapSlider.getButtonTarget(button);\n          const slider = window._SnapSliders[target.sliderID];\n\n          // Make sure slide index is valid.\n          const { index } = target;\n          const slideIndex = SnapSlider.isValidIndex(index)\n            ? `\"${index}\"`\n            : `🚫 \"${index}\" - Yikes! This index is invalid.\\n\\nUse a positive number instead, or one of the following aliases:\\n\n  ${['first', 'middle', 'last', 'prev', 'next'].map((a) => `• ${a}`).join('\\n')}`;\n\n          // \"We couldn't find anything.\"\n          const sliderID = target.sliderID\n            ? `\"${target.sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your button is inside a \\`data-snap-slider-nav\\` element, or...\n  • Include the slider ID you want to target in your \\`data-snap-slider-goto\\` attribute.\n      ◦ For example, \\`data-snap-slider-goto=\"example-slider:${target.index || 'prev'}\"\\`.`;\n\n          let sliderContainer = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your slider ID is correct (👆).\n  • Make sure your slider has the same ID in its \\`data-snap-slider\\` attribute.\n      ◦ For example, \\`data-snap-slider=\"example-slider\"\\`.`;\n          let slideIndexNumber = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your index is valid (👆).\n  • Make sure a slide actually exists at that index (👇).`;\n          let slide = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your index is valid (👆).\n  • Make sure a slide actually exists at that index.\n  • Make sure your slider recognizes the slide element as a slide.`;\n\n          // We found it!\n          if (slider && slider.container) {\n            sliderContainer = slider.container;\n            slideIndexNumber = slider.getIndexNumber(index);\n            slide = slider.getSlide(index);\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🕹 Button ${num}`,\n            description: button,\n            groups: [\n              {\n                heading: '1. What slider is this button targeting?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Element', description: sliderContainer },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. Which slide will it go to?',\n                items: [\n                  { heading: 'Slide Index', description: slideIndex },\n                  { heading: 'Slide Index (Number)', description: slideIndexNumber },\n                  { heading: 'Slide Element', description: slide },\n                ],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        // 2b. Navigation\n        if (nav) {\n          // Get details for the target slider\n          let sliderID = nav.getAttribute('data-snap-slider-nav');\n          const slider = window._SnapSliders[sliderID];\n          let buttons = qsa('[data-snap-slider-goto]', nav);\n\n          // \"We couldn't find anything.\"\n          sliderID = sliderID\n            ? `\"${sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Include the slider ID you want to target in your \\`data-snap-slider-nav\\` attribute.\n      ◦ For example, \\`data-snap-slider-nav=\"example-slider\"\\`.`;\n\n          let sliderContainer = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure the ID in your container's \\`data-snap-slider\\` attribute and the ID in your nav's \\`data-snap-slider-nav\\` attribute both match.`;\n\n          if (!buttons.length) {\n            buttons = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your buttons have a \\`data-snap-slider-goto\\` attribute.`;\n          }\n\n          // We found it!\n          if (slider && slider.container) {\n            sliderContainer = slider.container;\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🗺 Navigation ${num}`,\n            description: nav,\n            groups: [\n              {\n                heading: '1. What slider is this nav targeting?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Element', description: sliderContainer },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. What buttons are in this nav?',\n                items: [{ heading: 'Buttons', description: buttons }],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        // 2c. Containers (aka sliders)\n        if (container) {\n          // Get details for the slider.\n          let sliderID = container.getAttribute('data-snap-slider');\n          const slider = window._SnapSliders[sliderID];\n          let navs = qsa(`[data-snap-slider-nav=\"${sliderID}\"]`);\n          let buttons = slider ? slider.getButtons() : [];\n\n          // \"We couldn't find anything.\"\n          sliderID = sliderID\n            ? `\"${sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Include the slider ID you want in your \\`data-snap-slider\\` attribute.\n      ◦ For example, \\`data-snap-slider=\"example-slider\"\\`.`;\n\n          if (!navs.length) {\n            navs = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure the ID in your container's \\`data-snap-slider\\` attribute and the ID in your nav's \\`data-snap-slider-nav\\` attribute both match.`;\n          }\n\n          if (!buttons.length) {\n            buttons = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your button is inside a \\`data-snap-slider-nav\\` element, or...\n  • Include the slider ID you want to target in your \\`data-snap-slider-goto\\` attribute.\n      ◦ For example, \\`data-snap-slider-goto=\"example-slider:prev\"\\`.`;\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🥨 Slider ${num}`,\n            description: container,\n            groups: [\n              {\n                heading: '1. What slider is this?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. What navs target this slider?',\n                items: [{ heading: 'Navs', description: navs }],\n              },\n              {\n                heading: '3. What buttons target this slider?',\n                items: [{ heading: 'Buttons', description: buttons }],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        return SnapSlider.notFound(idOrElements);\n      });\n      /* eslint-enable no-irregular-whitespace */\n    }\n  }\n}\n\n// Keep track of all the sliders on the page to reference.\nwindow._SnapSliders = [];\n\n// Make the constructor globally accessible.\nwindow.SnapSlider = SnapSlider;\n\n// If jQuery exists, integrate.\nif (typeof $ !== 'undefined') {\n  // eslint-disable-next-line no-undef, func-names\n  $.fn.snapSlider = function (options) {\n    return new SnapSlider(this, options);\n  };\n}\n\n// Auto-init once the DOM is ready.\nonReady(() => {\n  // Init polyfills.\n  elementClosest(window);\n  smoothscroll.polyfill();\n\n  // Initialize all sliders with data attributes.\n  qsa('[data-snap-slider]').forEach((el) => new SnapSlider(el));\n\n  // Setup click events for *all* nav elements.\n  on('body', 'click', '[data-snap-slider-goto]', SnapSlider.handleGoto);\n});\n\nexport default SnapSlider;\n","import hasOwnProperty from './hasOwnProperty';\n\n/**\n * Get a computed style for some element.\n * @param  {Element}  el\n * @param  {String}   prop\n * @return {String}\n */\nexport default function getStyle(el, prop) {\n  const style = window.getComputedStyle(el);\n\n  // Ignore mmissing elements or props\n  if (!style || !hasOwnProperty(style, prop)) {\n    return '';\n  }\n\n  return style[prop];\n}\n","/**\n * Get an attribute for the closest element with it.\n * @param  {Element}  el\n * @param  {String}  attr\n * @return {String}\n */\nexport default function getClosestAttribute(el, attr) {\n  // Ignore missing elements\n  if (!el) {\n    return '';\n  }\n\n  // Find the closest element with a mattring attribute\n  el = el.closest(`[${attr}]`);\n\n  // If we found a match, return the attribute, otherwise\n  // return an empty string.\n  return el ? el.getAttribute(attr) : '';\n}\n","/**\n * Wait to run a function on DOMContentLoaded, or fire immediately if the\n * event has already fired.\n * @param  {Function} fn\n * @return {void}\n */\nexport default function onReady(fn) {\n  if (document.readyState !== 'loading') {\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', fn);\n  }\n}\n","/* eslint-disable consistent-return, func-names, no-var, prefer-arrow-callback, vars-on-top */\n\n/**\n * Plain JavaScript event delegation. Add a handler for whenever an element's\n * children trigger a specified event.\n * @see https://bdadam.com/blog/plain-javascript-event-delegation.html\n * @param  {String}    parentSelector\n * @param  {String}    eventName\n * @param  {String}    childSelector\n * @param  {Function}  fn\n * @return {Boolean}\n */\nexport default function on(parentSelector, eventName, childSelector, fn) {\n  var parent = document.querySelector(parentSelector);\n\n  if (!parent) {\n    return false;\n  }\n\n  parent.addEventListener(eventName, function (event) {\n    var possibleTargets = parent.querySelectorAll(childSelector);\n    var target = event.target;\n\n    for (var i = 0, l = possibleTargets.length; i < l; i += 1) {\n      var el = target;\n      var p = possibleTargets[i];\n\n      while (el && el !== parent) {\n        if (el === p) {\n          return fn.call(p, event);\n        }\n\n        el = el.parentNode;\n      }\n    }\n  });\n\n  return true;\n}\n\n// Example:\n// on('body', 'click', '.product', function(e) {\n//   console.log(e.target);\n// });\n"],"sourceRoot":""}