{"version":3,"sources":["webpack://SnapSlider/webpack/universalModuleDefinition","webpack://SnapSlider/webpack/bootstrap","webpack://SnapSlider/./node_modules/lodash/isObject.js","webpack://SnapSlider/./node_modules/lodash/debounce.js","webpack://SnapSlider/./node_modules/lodash/throttle.js","webpack://SnapSlider/./node_modules/lodash/_root.js","webpack://SnapSlider/./node_modules/lodash/_Symbol.js","webpack://SnapSlider/./node_modules/smoothscroll-polyfill/dist/smoothscroll.js","webpack://SnapSlider/./node_modules/tabbable/index.js","webpack://SnapSlider/./node_modules/lodash/now.js","webpack://SnapSlider/./node_modules/lodash/_freeGlobal.js","webpack://SnapSlider/(webpack)/buildin/global.js","webpack://SnapSlider/./node_modules/lodash/toNumber.js","webpack://SnapSlider/./node_modules/lodash/_baseTrim.js","webpack://SnapSlider/./node_modules/lodash/_trimmedEndIndex.js","webpack://SnapSlider/./node_modules/lodash/isSymbol.js","webpack://SnapSlider/./node_modules/lodash/_baseGetTag.js","webpack://SnapSlider/./node_modules/lodash/_getRawTag.js","webpack://SnapSlider/./node_modules/lodash/_objectToString.js","webpack://SnapSlider/./node_modules/lodash/isObjectLike.js","webpack://SnapSlider/./node_modules/element-closest/index.mjs","webpack://SnapSlider/./src/helpers/toArray.js","webpack://SnapSlider/./src/helpers/qsa.js","webpack://SnapSlider/./src/helpers/getElements.js","webpack://SnapSlider/./src/helpers/hasOwnProperty.js","webpack://SnapSlider/./src/helpers/isObject.js","webpack://SnapSlider/./src/helpers/minmax.js","webpack://SnapSlider/./src/helpers/passive.js","webpack://SnapSlider/./src/helpers/pick.js","webpack://SnapSlider/./src/helpers/values.js","webpack://SnapSlider/./src/snap-slider.js","webpack://SnapSlider/./src/helpers/getStyle.js","webpack://SnapSlider/./src/helpers/getClosestAttribute.js","webpack://SnapSlider/./src/helpers/onReady.js","webpack://SnapSlider/./src/helpers/on.js","webpack://SnapSlider/./src/helpers/dashes.js","webpack://SnapSlider/./src/modules/logger.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","type","isObject","now","toNumber","nativeMax","Math","max","nativeMin","min","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","arguments","this","clearTimeout","cancel","flush","debounce","freeGlobal","freeSelf","self","Function","polyfill","w","document","documentElement","style","__forceSmoothScrollPolyfill__","userAgent","Element","HTMLElement","original","scroll","scrollTo","scrollBy","elementScroll","scrollElement","scrollIntoView","performance","Date","ROUNDING_TOLERANCE","navigator","RegExp","join","test","shouldBailOut","smoothScroll","body","left","scrollX","pageXOffset","top","scrollY","pageYOffset","scrollLeft","scrollTop","SyntaxError","behavior","scrollableParent","findScrollableParent","parentRects","getBoundingClientRect","clientRects","getComputedStyle","position","x","y","firstArg","hasScrollableSpace","el","axis","clientHeight","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","isScrollable","isScrollableY","isScrollableX","parentNode","host","step","context","currentX","currentY","k","elapsed","startTime","cos","PI","startX","startY","method","scrollable","requestAnimationFrame","candidateSelectors","candidateSelector","matches","msMatchesSelector","webkitMatchesSelector","tabbable","candidate","candidateTabindex","regularTabbables","orderedTabbables","candidates","querySelectorAll","includeContainer","Array","slice","unshift","length","isNodeMatchingSelectorTabbable","getTabindex","push","documentOrder","tabIndex","node","sort","sortOrderedTabbables","map","a","concat","isNodeMatchingSelectorFocusable","isInput","isRadio","checked","nodes","getCheckedRadio","ownerDocument","isTabbableRadio","isNonTabbableRadio","disabled","isHiddenInput","offsetParent","visibility","isHidden","isTabbable","Error","isFocusable","focusableCandidateSelector","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","b","tagName","global","g","e","baseTrim","isSymbol","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","other","valueOf","isBinary","trimmedEndIndex","reTrimStart","string","replace","reWhitespace","index","charAt","baseGetTag","isObjectLike","getRawTag","objectToString","symToStringTag","objectProto","nativeObjectToString","toString","isOwn","tag","unmasked","ElementPrototype","mozMatchesSelector","selector","elements","Boolean","closest","element","nodeType","toArray","val","qsa","getElements","obj","prop","constructor","minmax","passive","opts","addEventListener","removeEventListener","error","pick","keys","reduce","values","arr","logger","require","counter","SnapSlider","containerOrOptions","terms","prev","next","callbacks","init","container","watchForChanges","_SnapSliders","id","indexOf","button","goto","split","str","trim","pop","sliderID","nav","slider","event","target","getButtonTarget","console","log","idOrElements","forEach","num","slideIndex","isValidIndex","sliderContainer","slideIndexNumber","slide","getIndexNumber","getSlide","section","heading","description","groups","items","collapsed","buttons","navs","getButtons","notFound","slides","start","loop","on","shift","eventName","getMaybeSetID","getMaybeSetSlides","align","getMaybeSetAlign","current","getMaybeSetStart","getMaybeSetLoop","transition","scrolling","navOptions","addGotoButtons","addNav","update","setAttribute","children","getStyle","attr","getClosestAttribute","ceil","getSnapAlign","offsetTop","offsetLeft","offsetHeight","offsetWidth","focus","force","ignoreCallbacks","immediate","getScrollOffset","startTransition","fireEvent","buildGoto","from","to","diff","abs","stuck","checkTransition","stopTransition","match","textContent","toLowerCase","className","isRelative","buttonsOrOptions","hasAttribute","setGoto","nextIndex","isPrevButton","isNextButton","updateButtons","filter","isCurrent","classList","add","remove","removeAttribute","tab","navContainers","navContainer","offset","scrollListener","throttle","getClosest","scrollEndListener","arrowKeyListener","defaultPrevented","isPrev","isNext","preventDefault","focusListener","contains","resizeObserver","observe","disconnect","ResizeObserver","resizeCallback","initialOptions","hasLoaded","updateSlides","handleFocus","events","callback","getCurrentSlide","preventScroll","activeElement","$","fn","snapSlider","readyState","onReady","elementClosest","smoothscroll","parentSelector","childSelector","parent","querySelector","possibleTargets","handleGoto","dashes","char","getSubstitution","params","group","content","item","groupEnd"],"mappings":"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","file":"snap-slider.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SnapSlider\"] = factory();\n\telse\n\t\troot[\"SnapSlider\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n(function () {\n  'use strict';\n\n  // polyfill\n  function polyfill() {\n    // aliases\n    var w = window;\n    var d = document;\n\n    // return if scroll behavior is supported and polyfill is not forced\n    if (\n      'scrollBehavior' in d.documentElement.style &&\n      w.__forceSmoothScrollPolyfill__ !== true\n    ) {\n      return;\n    }\n\n    // globals\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    // object gathering original scroll methods\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      elementScroll: Element.prototype.scroll || scrollElement,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    // define timing method\n    var now =\n      w.performance && w.performance.now\n        ? w.performance.now.bind(w.performance)\n        : Date.now;\n\n    /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */\n    function isMicrosoftBrowser(userAgent) {\n      var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n      return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n    }\n\n    /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */\n    var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */\n    function shouldBailOut(firstArg) {\n      if (\n        firstArg === null ||\n        typeof firstArg !== 'object' ||\n        firstArg.behavior === undefined ||\n        firstArg.behavior === 'auto' ||\n        firstArg.behavior === 'instant'\n      ) {\n        // first argument is not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError(\n        'behavior member of ScrollOptions ' +\n          firstArg.behavior +\n          ' is not a valid value for enumeration ScrollBehavior.'\n      );\n    }\n\n    /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function hasScrollableSpace(el, axis) {\n      if (axis === 'Y') {\n        return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n      }\n\n      if (axis === 'X') {\n        return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n      }\n    }\n\n    /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function canOverflow(el, axis) {\n      var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n      return overflowValue === 'auto' || overflowValue === 'scroll';\n    }\n\n    /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */\n    function isScrollable(el) {\n      var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n      var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n      return isScrollableY || isScrollableX;\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      while (el !== d.body && isScrollable(el) === false) {\n        el = el.parentNode || el.host;\n      }\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */\n    function step(context) {\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // scroll more if we have not reached our destination\n      if (currentX !== context.x || currentY !== context.y) {\n        w.requestAnimationFrame(step.bind(w, context));\n      }\n    }\n\n    /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y\n      });\n    }\n\n    // ORIGINAL METHODS OVERRIDES\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scroll.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object'\n              ? arguments[0]\n              : w.scrollX || w.pageXOffset,\n          // use top prop, second argument if present or fallback to scrollY\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined\n              ? arguments[1]\n              : w.scrollY || w.pageYOffset\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : w.scrollX || w.pageXOffset,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : w.scrollY || w.pageYOffset\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left !== undefined\n            ? arguments[0].left\n            : typeof arguments[0] !== 'object' ? arguments[0] : 0,\n          arguments[0].top !== undefined\n            ? arguments[0].top\n            : arguments[1] !== undefined ? arguments[1] : 0\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scroll and Element.prototype.scrollTo\n    Element.prototype.scroll = Element.prototype.scrollTo = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        // if one number is passed, throw error to match Firefox implementation\n        if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n          throw new SyntaxError('Value could not be converted');\n        }\n\n        original.elementScroll.call(\n          this,\n          // use left prop, first number argument or fallback to scrollLeft\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left\n            : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,\n          // use top prop, second argument or fallback to scrollTop\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top\n            : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop\n        );\n\n        return;\n      }\n\n      var left = arguments[0].left;\n      var top = arguments[0].top;\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        this,\n        this,\n        typeof left === 'undefined' ? this.scrollLeft : ~~left,\n        typeof top === 'undefined' ? this.scrollTop : ~~top\n      );\n    };\n\n    // Element.prototype.scrollBy\n    Element.prototype.scrollBy = function() {\n      // avoid action when no arguments are passed\n      if (arguments[0] === undefined) {\n        return;\n      }\n\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.elementScroll.call(\n          this,\n          arguments[0].left !== undefined\n            ? ~~arguments[0].left + this.scrollLeft\n            : ~~arguments[0] + this.scrollLeft,\n          arguments[0].top !== undefined\n            ? ~~arguments[0].top + this.scrollTop\n            : ~~arguments[1] + this.scrollTop\n        );\n\n        return;\n      }\n\n      this.scroll({\n        left: ~~arguments[0].left + this.scrollLeft,\n        top: ~~arguments[0].top + this.scrollTop,\n        behavior: arguments[0].behavior\n      });\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0]) === true) {\n        original.scrollIntoView.call(\n          this,\n          arguments[0] === undefined ? true : arguments[0]\n        );\n\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n\n        // reveal parent in viewport unless is fixed\n        if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n          w.scrollBy({\n            left: parentRects.left,\n            top: parentRects.top,\n            behavior: 'smooth'\n          });\n        }\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n\n}());\n","var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","function polyfill(window) {\n  var ElementPrototype = window.Element.prototype;\n\n  if (typeof ElementPrototype.matches !== 'function') {\n    ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.mozMatchesSelector || ElementPrototype.webkitMatchesSelector || function matches(selector) {\n      var element = this;\n      var elements = (element.document || element.ownerDocument).querySelectorAll(selector);\n      var index = 0;\n\n      while (elements[index] && elements[index] !== element) {\n        ++index;\n      }\n\n      return Boolean(elements[index]);\n    };\n  }\n\n  if (typeof ElementPrototype.closest !== 'function') {\n    ElementPrototype.closest = function closest(selector) {\n      var element = this;\n\n      while (element && element.nodeType === 1) {\n        if (element.matches(selector)) {\n          return element;\n        }\n\n        element = element.parentNode;\n      }\n\n      return null;\n    };\n  }\n}\n\nexport default polyfill;\n//# sourceMappingURL=index.mjs.map\n","/**\n * Convert a value to an array.\n * @param  {mixed}   val\n * @return {Array}\n */\nexport default function toArray(val) {\n  return Array.prototype.slice.call(val);\n}\n","import toArray from './toArray';\n\n/**\n * QSA = \"Query Selector All\" that returns an Array instead of a NodeList.\n * @param  {String}   selector\n * @param  {Element}  context\n * @return {Array}\n */\nexport default function qsa(selector, context) {\n  return selector ? toArray((context || document).querySelectorAll(selector)) : [];\n}\n","import qsa from './qsa';\n\n/**\n * Get an array of elements from a mixed-value parameter.\n * Accepts Strings, Elements, and Array-like values.\n * @param  {String|Element|Array}  elements\n * @param  {Element}  context\n * @return {Array}\n */\nexport default function getElements(elements, context) {\n  // 1. If value is a String, query the DOM\n  if (typeof elements === 'string') {\n    return qsa(elements, context);\n  }\n\n  // 2. Put single element in an Array\n  if (elements instanceof Element) {\n    return [elements];\n  }\n\n  // 3. Assume everything can be treated like an Array\n  if (elements) {\n    return Array.prototype.slice.call(elements);\n  }\n\n  // 4. Otherwise, fallback to an empty array\n  return [];\n}\n","/**\n * Check whether an object actually has a property.\n * @param  {Object} obj\n * @param  {String} prop\n * @return {Boolean}\n */\nexport default function hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","/**\n * Strict check for Objects. Literally checks whether\n * the value's constructor is \"Object\".\n * @param  {mixed}  val\n * @return {String}\n */\nexport default function isObject(val) {\n  return val && val.constructor.name === 'Object';\n}\n","/**\n * Keep a value within some minimum and maximum values.\n * @param  {Number}  value\n * @param  {Number}  min\n * @param  {Number}  max\n * @return {Number}\n */\nexport default function minmax(value, min, max) {\n  value = Math.min(max, value);\n  value = Math.max(min, value);\n  return value;\n}\n","/* eslint-disable getter-return */\n\n/**\n * Passive Event Listeners.\n *\n * Pass this value as a 3rd argument to your event listeners\n * to dramatically improve performance.\n *\n * @see https://developers.google.com/web/updates/2016/06/passive-event-listeners\n * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n * @type {Boolean}\n */\nconst passive = (() => {\n  let result = false;\n\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        result = { passive: true };\n      },\n    });\n    window.addEventListener('testPassive', null, opts);\n    window.removeEventListener('testPassive', null, opts);\n  } catch (error) {\n    // 🤫\n  }\n\n  return result;\n})();\n\nexport default passive;\n","/**\n * Pick keys from an object.\n * @param  {Object} obj\n * @param  {Array}  keys\n * @return {Object}\n */\nexport default function pick(obj, keys) {\n  return keys.reduce((result, key) => {\n    result[key] = obj[key];\n\n    return result;\n  }, {});\n}\n","/* eslint-disable no-restricted-syntax, no-var, vars-on-top */\n\nimport hasOwnProperty from './hasOwnProperty';\n\n/**\n * Helper that does the same thing as `Object.values()`. Works in IE!\n * @param  {Object}  obj\n * @return {Array}\n */\nfunction values(obj) {\n  var arr = [];\n\n  for (var prop in obj) {\n    if (hasOwnProperty(obj, prop)) {\n      arr.push(obj[prop]);\n    }\n  }\n\n  return arr;\n}\n\n// Use native code if supported, else return polyfill.\n// eslint-disable-next-line no-confusing-arrow\nconst fn = (() => typeof Object.values === 'function' ? Object.values : values)();\n\nexport default fn;\n","// Dependencies\nimport elementClosest from 'element-closest';\nimport smoothscroll from 'smoothscroll-polyfill';\nimport tabbable from 'tabbable';\n\n// Helpers\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nimport getClosestAttribute from './helpers/getClosestAttribute';\nimport getElements from './helpers/getElements';\nimport getStyle from './helpers/getStyle';\nimport hasOwnProperty from './helpers/hasOwnProperty';\nimport isObject from './helpers/isObject';\nimport minmax from './helpers/minmax';\nimport on from './helpers/on';\nimport onReady from './helpers/onReady';\nimport passive from './helpers/passive';\nimport pick from './helpers/pick';\nimport qsa from './helpers/qsa';\nimport toArray from './helpers/toArray';\nimport values from './helpers/values';\n\n// Modules\nconst logger = (process.env.NODE_ENV !== 'production')\n  ? require('./modules/logger')\n  : {};\n\n// Internal Variables\nlet counter = 1;\n\n/**\n * Snap Slider.\n * @class\n */\nclass SnapSlider {\n  /**\n   * New Snap Slider.\n   *\n   * See `init()` for a full breakdown of `options`.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @constructor\n   */\n  constructor(containerOrOptions, options = {}) {\n    // Setup internal variables.\n    this.terms = {\n      prev: /(prev|back|before|left|up)/,\n      next: /(next|forward|after|right|down)/,\n    };\n\n    /* eslint-disable quote-props */\n    this.callbacks = {\n      'load': [],\n      'change': [],\n      'change.click': [],\n      'change.scroll': [],\n      'change.keydown': [],\n      'change.focusin': [],\n      'scroll': [],\n      'scroll.start': [],\n      'scroll.end': [],\n    };\n    /* eslint-enable quote-props */\n\n    this.init(containerOrOptions, options);\n\n    // Don't construct sliders with empty containers.\n    if (!this.container) {\n      return;\n    }\n\n    this.watchForChanges();\n\n    // Keep track of the slider so we can reference & debug it later.\n    this.container.SnapSlider = this;\n    window._SnapSliders[this.id] = this;\n  }\n\n  /**\n   * Initialize this slider.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String}                       options.id\n   * @param  {String|Element|Array}         options.slides\n   * @param  {String|Number}                options.start\n   * @param  {String|Element|Array}         options.nav\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {void}\n   */\n  init(containerOrOptions, options = {}) {\n    // Allow people to quickly spin up sliders by just passing a container\n    // element, or by passing in a single options object.\n    if (isObject(containerOrOptions)) {\n      options = containerOrOptions;\n    }\n\n    // Fill default options.\n    this.options = {\n      container: containerOrOptions,\n      id: '',\n      slides: '',\n      nav: '',\n      buttons: '',\n      prev: '',\n      next: '',\n      start: 0,\n      loop: null,\n      on: {},\n      ...options,\n    };\n\n    // Get single element from params.\n    const container = getElements(this.options.container).shift();\n\n    // Don't construct sliders with empty containers.\n    if (!container) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n🚫 Whoops! Snap Slider can't find a container element matching \"${this.options.container}\".\\n\n🔍 Please check your selectors for typos. Make sure the element actually exists\n   in the DOM when Snap Slider tries to initialize it.\\n\n👇 Here's a copy of the options you tried to initialize with for debugging:\\n\\n`, this.options, '\\n\\n');\n      }\n      return;\n    }\n\n    // Great! Now let's start initializing everything.\n    this.container = container;\n\n    // Get selectors from JavaScript or data attributes.\n    this.options.buttons = options.buttons || this.container.getAttribute('data-snap-slider-buttons');\n    this.options.prev = options.prev || this.container.getAttribute('data-snap-slider-prev');\n    this.options.next = options.next || this.container.getAttribute('data-snap-slider-next');\n\n    // Get and set persistent options in data attributes.\n    this.id = this.getMaybeSetID(container, this.options.id);\n    this.slides = this.getMaybeSetSlides(container, this.options.slides);\n    this.align = this.getMaybeSetAlign(container, this.options.align);\n    this.current = this.getMaybeSetStart(container, this.options.start);\n    this.loop = this.getMaybeSetLoop(container, this.options.loop);\n\n    // Reset internal variables.\n    this.transition = null;\n    this.scrolling = false;\n\n    // Add custom callbacks.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const eventName in this.options.on) {\n      if (hasOwnProperty(this.options.on, eventName)) {\n        this.on(eventName, this.options.on[eventName]);\n      }\n    }\n\n    // Setup navigation.\n    // NOTE: If left blank, `addNav()` will handle the fallbacks for button selectors.\n    const navOptions = pick(this.options, [\n      'buttons',\n      'prev',\n      'next',\n    ]);\n\n    // Init custom goto buttons in the container.\n    // NOTE: \"Goto\" buttons are automatically handled by delegated click\n    // events on the `body`. For more details, see `handleGotoClick()`.\n    this.addGotoButtons({ ...navOptions, container });\n\n    // Init standard navs with data attributes.\n    this.addNav(`[data-snap-slider-nav=\"${this.id}\"]`, navOptions);\n\n    // Then init custom navs too.\n    if (this.options.nav) {\n      this.addNav(this.options.nav, navOptions);\n    }\n\n    // Go to the slide we want to start on.\n    this.update();\n  }\n\n  /**\n   * Get and maybe set a slider's ID on the closest container element.\n   *\n   * If no ID was specified, generates a fallback ID.\n   *\n   * @param  {Element}  container\n   * @param  {String}   id\n   * @return {String}\n   */\n  getMaybeSetID(container, id) {\n    // Either use the ID we were given or the ID already on the container.\n    id = id\n      || container.getAttribute('data-snap-slider')\n      || container.id;\n\n    // If we don't have an ID, make one up and increment our internal\n    // counter for the next slider.\n    if (!id) {\n      id = `slider-${counter}`;\n      counter += 1;\n    }\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider', id);\n\n    // Return the final ID.\n    return id;\n  }\n\n  /**\n   * Get all slide elements for a given container.\n   *\n   * Defaults to container's children.\n   *\n   * @param  {Element}  container\n   * @param  {String}   selector\n   * @return {Array}\n   */\n  getMaybeSetSlides(container, selector) {\n    // Get selector from JavaScript or data attribute.\n    selector = selector && typeof selector === 'string'\n      ? selector\n      : container.getAttribute('data-snap-slider-slides');\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-slides', selector || '');\n\n    // If selector exists, use those elements. Otherwise,\n    // assume the container's immediate children are slides.\n    const slides = selector\n      ? getElements(selector, container)\n      : toArray(container.children);\n\n    // Ensure all slides are focusable but not tabbable.\n    slides.forEach((slide) => slide.setAttribute('tabindex', '-1'));\n\n    // Return array of slides.\n    return slides;\n  }\n\n  /**\n   * Get alignment fallback for a given container.\n   *\n   * @param  {Element}  container\n   * @param  {String}   align\n   * @return {String}\n   */\n  getMaybeSetAlign(container, align) {\n    // Get align index from JavaScript, data attribute, or leave blank.\n    align = align || container.getAttribute('data-snap-slider-align') || '';\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-align', align);\n\n    return align;\n  }\n\n  /**\n   * Get start index for a given container.\n   *\n   * Defaults to 1.\n   *\n   * @param  {Element}  container\n   * @param  {String}   start\n   * @return {String|Number}\n   */\n  getMaybeSetStart(container, start) {\n    // Get start index from JavaScript, data attribute, or default to 1.\n    if (!SnapSlider.isValidIndex(start)) {\n      start = container.getAttribute('data-snap-slider-start') || 1;\n    }\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-start', start);\n\n    return start;\n  }\n\n  /**\n   * Get and maybe set a slider's `loop` option on the closest container element.\n   *\n   * @param  {Element}  container\n   * @param  {Boolean}  loop\n   * @return {String}\n   */\n  getMaybeSetLoop(container, loop) {\n    // If we were given a Boolean value to set, use that.\n    // Else check for an existing data attribute.\n    // Defaults to `false`.\n    loop = typeof loop === 'boolean'\n      ? loop\n      : container.getAttribute('data-snap-slider-loop') === 'true';\n\n    // Store value in data attribute.\n    container.setAttribute('data-snap-slider-loop', loop);\n\n    // Return the final loop value.\n    return loop;\n  }\n\n  /**\n   * Get the `scroll-snap-align` for a snap slider element.\n   *\n   * Falls back to `data-snap-slider-align` when no CSS\n   * is detected, otherwise defaults to `start`.\n   *\n   * @param  {Element}  el\n   * @return {String}\n   */\n  getSnapAlign(el) {\n    // Get element's CSS align value.\n    const style = getStyle(el, 'scrollSnapAlign');\n\n    // If browser supports Scroll Snap and slide\n    // has a non-empty value, return it.\n    if (style && style.indexOf('none') < 0) {\n      return style;\n    }\n\n    // Otherwise, fallback to the slider's align attribute.\n    // Else assume \"start\" for everything.\n    return getClosestAttribute(el, 'data-snap-slider-align')\n      || 'start';\n  }\n\n  /**\n   * Get a specific slide element. Accepts any valid goto alias.\n   *\n   * @param  {Number}   index  Starts at 1.\n   * @return {Element}\n   */\n  getSlide(index) {\n    // Convert index aliases to numbers.\n    index = this.getIndexNumber(index);\n\n    // Return the slide for that numeric index.\n    // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n    return this.slides[index - 1];\n  }\n\n  /**\n   * Get the current slide element.\n   *\n   * @return {Element}\n   */\n  getCurrentSlide() {\n    // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n    return this.slides[this.current - 1];\n  }\n\n  /**\n   * Is this a valid index?\n   *\n   * - first\n   * - middle\n   * - last\n   * - prev\n   * - next\n   *\n   * @param  {String|Number}  index\n   * @return {Number}\n   */\n  static isValidIndex(index) {\n    const aliases = [\n      'first',\n      'middle',\n      'last',\n      'prev',\n      'next',\n    ];\n\n    // Valid indexes are either a known alias,\n    // or a positive integer.\n    return aliases.indexOf(index) >= 0\n      || parseInt(index, 10) >= 1;\n  }\n\n  /**\n   * Get the slide number for any index.\n   *\n   * Returns -1 if index is invalid.\n   *\n   * @param  {String|Number}  index\n   * @return {Number}\n   */\n  getIndexNumber(index) {\n    let num;\n\n    if (index === 'first') {\n      // Get the first slide.\n      num = 1;\n    } else if (index === 'middle') {\n      // Get the middle slide.\n      num = Math.ceil(this.slides.length / 2);\n    } else if (index === 'last') {\n      // Get the last slide.\n      num = this.slides.length;\n    } else if (index === 'prev') {\n      // Get the previous slide.\n      num = this.current - 1;\n    } else if (index === 'next') {\n      // Get the next slide.\n      num = this.current + 1;\n    } else {\n      // Try to get a number.\n      num = parseInt(index, 10) || -1;\n    }\n\n    if (this.loop) {\n      // If we're looping, send out-of-bounds requests\n      // to the other end of the slider.\n      if (num < 1) {\n        num = this.slides.length;\n      }\n\n      if (num > this.slides.length) {\n        num = 1;\n      }\n    } else if (num < 1 || num > this.slides.length) {\n      // Otherwise, ignore out-of-range indexes.\n      num = -1;\n    }\n\n    // Return numeric index. Or, if something goes wrong,\n    // fallback to the first slide.\n    return num || 1;\n  }\n\n  /**\n   * Get the offset we should scroll to for a specific slide.\n   *\n   * @param  {Element}  slide\n   * @return {Object}   { top, left }\n   */\n  getScrollOffset(slide) {\n    const { container } = this;\n    const align = this.getSnapAlign(slide);\n\n    // Calculate the 'start' position by default.\n    // NOTE: This forces slides with align `none` to still snap into place.\n    let top = slide.offsetTop;\n    let left = slide.offsetLeft;\n\n    // NOTE: Because Safari uses the 2-value syntax, we simply check for matching\n    // keywords. If this causes incorrect behavior, use the `data-snap-slider-align`\n    // attribute to override our automatic CSS detection.\n    if (align.indexOf('center') >= 0) {\n      // To center a slide, start with its beginning offset (the 'start' position).\n      // Then add half the slide's size minus half the container size.\n      top = slide.offsetTop + slide.offsetHeight / 2 - container.offsetHeight / 2;\n      left = slide.offsetLeft + slide.offsetWidth / 2 - container.offsetWidth / 2;\n    } else if (align.indexOf('end') >= 0) {\n      // To align the end of a slide, start with its beginning offset (the 'start' position).\n      // Then subtract the size of the container, but add back the size of the slide.\n      top = slide.offsetTop - container.offsetHeight + slide.offsetHeight;\n      left = slide.offsetLeft - container.offsetWidth + slide.offsetWidth;\n    }\n\n    // Keep offsets within the scrollable area.\n    top = minmax(top, 0, container.scrollHeight);\n    left = minmax(left, 0, container.scrollWidth);\n\n    return { top, left };\n  }\n\n  /**\n   * Go to a slide.\n   *\n   * @param  {String|Number}  index                    Starts at 1.\n   * @param  {Object}         options\n   * @param  {Boolean}        options.focus\n   * @param  {Boolean}        options.force\n   * @param  {Boolean}        options.ignoreCallbacks\n   * @param  {Boolean}        options.immediate\n   * @param  {Event}          event\n   * @return {Boolean}\n   */\n  goto(index, options = {}, event) {\n    // Fill default options.\n    options = {\n      // By default, focus the slide we're going to.\n      focus: true,\n      // Force-update the scroll position, even if we're already on the current slide.\n      force: false,\n      // Ignore custom callbacks for events.\n      ignoreCallbacks: false,\n      // Immediately update position without smooth scrolling.\n      immediate: false,\n      ...options,\n    };\n\n    // Get the next slide we should go to.\n    const next = this.getIndexNumber(index);\n\n    // If nothing changed, don't do anything (as long as\n    // we're not trying to force it).\n    if (!options.force && next === this.current) {\n      return false;\n    }\n\n    // Get the next slide.\n    const slide = this.getSlide(next);\n\n    if (!slide) {\n      return false;\n    }\n\n    // Scroll to it!\n    const { top, left } = this.getScrollOffset(slide);\n\n    if (options.immediate) {\n      // Scroll immediately.\n      this.container.scroll({ top, left });\n    } else {\n      // Let the event handlers know we're coming, then smooth scroll.\n      this.startTransition(next);\n      this.container.scroll({ top, left, behavior: 'smooth' });\n    }\n\n    // Update state.\n    this.current = next;\n\n    // We changed slides!\n    this.fireEvent('change', event, options);\n\n    return true;\n  }\n\n  /**\n   * Build the `goto` attribute for a nav button.\n   *\n   * @param  {Element|Boolean}  nav\n   * @param  {String|Number}    index\n   * @return {String}\n   */\n  buildGoto(nav, index = '') {\n    // Start with an empty string.\n    let goto = '';\n\n    // If this button isn't part of a nav, include the slider ID.\n    if (!nav) {\n      goto += `${this.id}:`;\n    }\n\n    // Add the index and return.\n    return goto + index;\n  }\n\n  /**\n   * Set the `goto` attribute for nav buttons.\n   *\n   * @param  {String|Element|Array}  buttons\n   * @param  {String}                index\n   * @return {void}\n   */\n  setGoto(buttons, index) {\n    buttons = getElements(buttons);\n\n    // If we found custom prev/next buttons, set their `goto` attributes\n    // before we loop through the rest of the buttons.\n    buttons.forEach((button) => {\n      button.setAttribute('data-snap-slider-goto', this.buildGoto(\n        // Don't assume this button is grouped with the others. It may\n        // be somewhere else on the page, so double check for a parent\n        // slider or nav container.\n        button.closest('[data-snap-slider], [data-snap-slider-nav]'),\n        index,\n      ));\n    });\n  }\n\n  /**\n   * Get the slider ID and slide index a goto button is targeting.\n   *\n   * NOTE: This method is static so we can call it in the delegated body\n   * click events. For more details, see `handleGotoClick()`.\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Object}                { sliderID, index }\n   */\n  static getButtonTarget(button) {\n    // Where are we going?\n    const goto = button ? button.getAttribute('data-snap-slider-goto') : '';\n\n    // Ignore missing buttons and attributes.\n    if (!goto) {\n      return {};\n    }\n\n    // Parse slide index and slider ID from `goto` attribute.\n    const args = goto.split(':').map((str) => str.trim());\n    const index = args.pop();\n    let sliderID = args.pop();\n\n    // If the slider ID wasn't included, check for a parent nav or container element.\n    if (!sliderID) {\n      const nav = button.closest('[data-snap-slider-nav]');\n      const container = button.closest('[data-snap-slider]');\n\n      // If it is in a nav or container, get the slider ID from there.\n      if (nav) {\n        sliderID = nav.getAttribute('data-snap-slider-nav');\n      }\n\n      if (container) {\n        sliderID = container.getAttribute('data-snap-slider');\n      }\n    }\n\n    // If there's still no slider ID, is this button already in a slider?\n    if (!sliderID) {\n      const slider = button.closest('data-snap-slider');\n\n      // If it is in a slider, get the slider ID from there.\n      if (slider) {\n        sliderID = slider.getAttribute('data-snap-slider');\n      }\n    }\n\n    return { sliderID, index };\n  }\n\n  /**\n   * Handle click events for nav (aka \"goto\") buttons.\n   *\n   * By delegating events to the body, we can automatically\n   * handle dynamic goto buttons (i.e., without having to\n   * reinitialize slider events).\n   *\n   * @param  {Event}  event\n   * @return {void}\n   */\n  static handleGoto(event) {\n    // Get the button we clicked.\n    const button = event.target.closest('[data-snap-slider-goto]');\n\n    // Get the slider we're trying to update.\n    const { sliderID, index } = SnapSlider.getButtonTarget(button);\n    const slider = window._SnapSliders[sliderID];\n\n    // Make sure it actually exists.\n    if (!slider) {\n      return;\n    }\n\n    // Go! But only focus the slide if we're NOT clicking a prev/next button.\n    slider.goto(index, null, event);\n  }\n\n  /**\n   * Start transitioning to another slide.\n   *\n   * This way when you click a nav button, the current slide updates\n   * immediately but the scroll listener doesn't override it, or fire\n   * extra change events.\n   *\n   * @param  {Number}  next\n   * @return {void}\n   */\n  startTransition(next) {\n    // Tell the scroll listener which slide we're transitioning to.\n    this.transition = {\n      from: this.current,\n      to: next,\n      diff: Math.abs(next - this.current),\n    };\n\n    // In case someone's fast enough to start scrolling again before our\n    // scroll listener resolves the `transition` flag, or if the slide's\n    // already visible and nothing actually has to scroll,\n    // set a timeout to resolve the transition.\n    const stuck = this.transition.to;\n\n    // If there's already a check waiting, clear it to avoid accidentally\n    // reverting to the wrong slide.\n    if (this.checkTransition) {\n      clearTimeout(this.checkTransition);\n    }\n\n    // Now make sure we don't get stuck!\n    this.checkTransition = setTimeout(() => {\n      if (this.transition.to === stuck) {\n        this.stopTransition();\n      }\n    }, 1000);\n  }\n\n  /**\n   * Stop the transitions! Set things back to normal.\n   *\n   * @return {void}\n   */\n  stopTransition() {\n    // Clear transition checks.\n    this.transition = null;\n    clearTimeout(this.checkTransition);\n  }\n\n  /**\n   * Is this a \"previous\" button?\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Boolean}\n   */\n  isPrevButton(button) {\n    button = getElements(button).shift();\n\n    // Ignore missing elements.\n    if (!button) {\n      return false;\n    }\n\n    // Check whether the `goto` attribute is \"prev\".\n    // If not, check the text & class for common \"prev\" terms.\n    return (button.getAttribute('data-snap-slider-goto') || '').match(/\\bprev$/)\n      || button.textContent.toLowerCase().match(this.terms.prev)\n      || button.className.toLowerCase().match(this.terms.prev);\n  }\n\n  /**\n   * Is this a \"next\" button?\n   *\n   * @param  {String|Element|Array}  button\n   * @return {Boolean}\n   */\n  isNextButton(button) {\n    button = getElements(button).shift();\n\n    // Ignore missing elements.\n    if (!button) {\n      return false;\n    }\n\n    // Check whether the `goto` attribute is \"next\".\n    // If not, check the text & class for common \"next\" terms.\n    return (button.getAttribute('data-snap-slider-goto') || '').match(/\\bnext$/)\n      || button.textContent.toLowerCase().match(this.terms.next)\n      || button.className.toLowerCase().match(this.terms.next);\n  }\n\n  /**\n   * Is this index a relative term? I.e., is it `prev` or `next`?\n   *\n   * @param  {String|Number}  index\n   * @return {Boolean}\n   */\n  static isRelative(index) {\n    return index === 'prev' || index === 'next';\n  }\n\n  /**\n   * Does an index match the current slide?\n   *\n   * @param  {String|Number}  index\n   * @return {Boolean}\n   */\n  isCurrent(index) {\n    // Ignore relative indexes (i.e., `prev` and `next`) since they\n    // always refer to one more or less than the current index.\n    if (SnapSlider.isRelative(index)) {\n      return false;\n    }\n\n    // Does this numeric index match the current slide?\n    return this.getIndexNumber(index) === this.current;\n  }\n\n  /**\n   * Add goto buttons for the current slider.\n   *\n   * @param  {String|Element|Array|Object}  buttonsOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {Boolean}\n   */\n  addGotoButtons(buttonsOrOptions, options = {}) {\n    // Allow people to quickly add nav buttons by just passing the\n    // selector, or by passing in a single options object.\n    if (isObject(buttonsOrOptions)) {\n      options = buttonsOrOptions;\n    }\n\n    // Fill default options.\n    options = {\n      container: '',\n      buttons: buttonsOrOptions,\n      prev: '',\n      next: '',\n      ...options,\n    };\n\n    // Get button elements.\n    // NOTE: If someone passes an overly-generic selector (e.g., `button`)\n    // this will query the entire document. In general, you should either\n    // specify a container element, use specific selectors, or pass\n    // the elements directly.\n    const buttons = getElements(options.buttons, options.container);\n    const prev = getElements(options.prev, options.container);\n    const next = getElements(options.next, options.container);\n\n    // If we found custom prev/next buttons, set their `goto` attributes\n    // before we loop through the rest of the buttons.\n    prev.forEach((b) => b.hasAttribute('data-snap-slider-goto') || this.setGoto(prev, 'prev'));\n    next.forEach((b) => b.hasAttribute('data-snap-slider-goto') || this.setGoto(next, 'next'));\n\n    // Keep track of the index outside of the loop so we can\n    // skip prev/next buttons but still go in order.\n    let nextIndex = 1;\n\n    // Loop through the buttons and set each one's `goto` attribute.\n    buttons.forEach((button) => {\n      // Ignore buttons that already have a `goto` attribute.\n      if (button.hasAttribute('data-snap-slider-goto')) {\n        return null;\n      }\n\n      // Previous\n      if (this.isPrevButton(button)) {\n        return this.setGoto(button, 'prev');\n      }\n\n      // Next\n      if (this.isNextButton(button)) {\n        return this.setGoto(button, 'next');\n      }\n\n      // Numeric: Check the text for a number, else fallback to the next index.\n      const index = parseInt(button.textContent.replace(/.*\\b(\\d+)\\b.*/, '$1'), 10) || nextIndex;\n\n      // Increment the next index.\n      nextIndex = index + 1;\n\n      return this.setGoto(button, index);\n    });\n\n    this.updateButtons();\n\n    return true;\n  }\n\n  /**\n   * Get navs for the current slider.\n   *\n   * @return {Array}\n   */\n  getNavs() {\n    // eslint-disable-next-line arrow-body-style\n    return qsa('[data-snap-slider-nav]').filter((nav) => {\n      // Only return navs targeting the current slider.\n      return nav.getAttribute('data-snap-slider-nav') === this.id;\n    });\n  }\n\n  /**\n   * Get nav buttons for the current slider.\n   *\n   * @return {Array}\n   */\n  getButtons() {\n    return qsa('[data-snap-slider-goto]').filter((button) => {\n      const { sliderID } = SnapSlider.getButtonTarget(button);\n      // Only return buttons targeting the current slider.\n      return sliderID === this.id;\n    });\n  }\n\n  /**\n   * Update nav buttons for the current slider.\n   *\n   * @return {void}\n   */\n  updateButtons() {\n    // Wait until the slider has initialized.\n    if (!this.current) {\n      return;\n    }\n\n    // Loop through all the nav buttons.\n    this.getButtons().forEach((button) => {\n      // Figure out which slide it's for...\n      const { index } = SnapSlider.getButtonTarget(button);\n\n      // And update its class.\n      if (this.isCurrent(index)) {\n        button.classList.add('is-current');\n      } else {\n        button.classList.remove('is-current');\n      }\n\n      // Also, enable/disable relative buttons unless `loop` is on.\n      if (!this.loop && SnapSlider.isRelative(index)) {\n        // Disable prev button on first slide.\n        // Disable next button on last slide.\n        const disabled = (index === 'prev' && this.current === 1)\n          || (index === 'next' && this.current === this.slides.length);\n\n        if (disabled) {\n          // button.setAttribute('disabled', '');\n          button.classList.add('is-disabled');\n        } else {\n          // button.removeAttribute('disabled', '');\n          button.classList.remove('is-disabled');\n        }\n      }\n    });\n  }\n\n  /**\n   * Update slide active states when the slider changes.\n   *\n   * @return {void}\n   */\n  updateSlides() {\n    this.slides.forEach((slide, index) => {\n      // NOTE: Subtract 1 because the array is 0-index, but our API is 1-index.\n      if (index === this.current - 1) {\n        slide.classList.add('is-current');\n        slide.removeAttribute('aria-hidden');\n\n        // Enable tabbing for current slide\n        qsa('[data-snap-slider-tabindex]', slide).forEach((tab) => {\n          tab.removeAttribute('tabindex');\n        });\n      } else {\n        slide.classList.remove('is-current');\n        slide.setAttribute('aria-hidden', 'true');\n\n        // Disable tabbing for non-current slides\n        tabbable(slide).forEach((tab) => {\n          tab.setAttribute('tabindex', '-1');\n          tab.setAttribute('data-snap-slider-tabindex', '');\n        });\n      }\n    });\n  }\n\n  /**\n   * Add a nav element for the current slider. Automatically hooks up any nav\n   * buttons inside the nav.\n   *\n   * @param  {String|Element|Array|Object}  containerOrOptions\n   * @param  {Object}                       options\n   * @param  {String|Element|Array}         options.container\n   * @param  {String|Element|Array}         options.buttons\n   * @param  {String|Element|Array}         options.prev\n   * @param  {String|Element|Array}         options.next\n   * @return {Boolean}\n   */\n  addNav(containerOrOptions, options = {}) {\n    // Allow people to quickly add a nav by just passing a container\n    // element, or by passing in a single options object.\n    if (isObject(containerOrOptions)) {\n      options = containerOrOptions;\n    }\n\n    // Fill default options.\n    options = {\n      container: containerOrOptions,\n      buttons: '',\n      prev: '',\n      next: '',\n      ...options,\n    };\n\n    // Get matching nav containers.\n    const navContainers = getElements(options.container);\n\n    // Don't add navs without container elements.\n    if (!navContainers.length) {\n      return false;\n    }\n\n    navContainers.forEach((navContainer) => {\n      // Set a data attribute assigning the nav to this slider.\n      navContainer.setAttribute('data-snap-slider-nav', this.id);\n\n      // Get button selectors from JavaScript, data attribute, or default to 'button'.\n      // NOTE: In this case, allow the nav's data attribute to override the parent\n      // container's options.\n      const buttons = navContainer.getAttribute('data-snap-slider-buttons')\n        || options.buttons\n        || 'button';\n      const prev = options.prev || navContainer.getAttribute('data-snap-slider-prev');\n      const next = options.next || navContainer.getAttribute('data-snap-slider-next');\n\n      // And add them.\n      this.addGotoButtons({\n        container: navContainer,\n        buttons,\n        prev,\n        next,\n      });\n    });\n\n    return true;\n  }\n\n  /**\n   * Which slide is closest to its active offset position?\n   *\n   * Returns an object include the slide's index, element,\n   * and the diff between its active offset and our\n   * current scroll position.\n   *\n   * @return {Object}  { index, slide, diff }\n   */\n  getClosest() {\n    return this.slides.reduce((prev, slide, index) => {\n      // 1-index to stay consistent with our API.\n      index += 1;\n\n      // How far away are we from the next slide's active offset position?\n      const offset = this.getScrollOffset(slide);\n      const diff = {\n        top: Math.abs(this.container.scrollTop - offset.top),\n        left: Math.abs(this.container.scrollLeft - offset.left),\n      };\n\n      // Save the next slide's info to compare with other slides.\n      const next = { index, slide, diff };\n\n      // If this is the first slide, return it and compare the next one.\n      if (!prev) {\n        return next;\n      }\n\n      // Compare each slide to see which one is the closest to its active offset position.\n      // As soon as the next slide is at least as close as the previous one, return it.\n      if (next.diff.left <= prev.diff.left && next.diff.top <= prev.diff.top) {\n        return next;\n      }\n\n      // Otherwise, keep the last closest slide.\n      return prev;\n    // Init with `false` so the first slide gets processed just like the rest of them.\n    }, false);\n  }\n\n  /**\n   * Watch the container scroll for when the current slide changes.\n   *\n   * @return {void}\n   */\n  watchForChanges() {\n    // Scroll listener. Save so we can remove it during `destroy()`.\n    this.scrollListener = throttle((event) => {\n      // Which slide is closest to their active offset position?\n      const closest = this.getClosest();\n\n      // If someone's passively scrolling (i.e., not in a transition),\n      // then  as soon as we've scrolled to another slide, mark that\n      // slide as the new current one and fire a change event.\n      if (!this.transition && closest.index !== this.current) {\n        this.current = closest.index;\n        this.fireEvent('change', event);\n      }\n\n      // If we just started scrolling, update state and\n      // fire a `scroll.start` event.\n      if (!this.scrolling) {\n        this.scrolling = true;\n        this.fireEvent('scroll.start', event);\n      }\n\n      // Fire a generic `scroll` event.\n      this.fireEvent('scroll', event);\n    }, 250);\n\n    // Scroll end listener. Save so we can remove it during `destroy()`.\n    this.scrollEndListener = debounce((event) => {\n      // We're done scrolling!\n      this.scrolling = false;\n      this.fireEvent('scroll.end', event);\n\n      // Clear any previous transition checks.\n      // NOTE: This has to happen *after* we fire the `scroll.end` event,\n      // otherwise `handleFocus` won't be able to access `this.transition`.\n      this.stopTransition();\n    }, 250);\n\n    // Arrow key listener. Save so we can remove it during `destroy()`.\n    this.arrowKeyListener = throttle((event) => {\n      // Ignore events that have already been prevented.\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      // Listen for arrow keys.\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n      const isPrev = ['Up', 'ArrowUp', 'Left', 'ArrowLeft'].indexOf(event.key) >= 0;\n      const isNext = ['Down', 'ArrowDown', 'Right', 'ArrowRight'].indexOf(event.key) >= 0;\n\n      // Ignore non-arrow keys.\n      if (!isPrev && !isNext) {\n        return;\n      }\n\n      // Go to the next or previous slide.\n      this.goto(isNext ? 'next' : 'prev', null, event);\n\n      // Prevent default browser scroll.\n      event.preventDefault();\n    }, 250);\n\n    // Focus listener. Save so we can remove it during `destroy()`.\n    this.focusListener = (event) => {\n      // Only trigger `goto` on focus when we're not passively scrolling.\n      // However, if someone manually triggered a transition then\n      // allow them to click or tab away to a different slide.\n      if (this.scrolling && !this.transition) {\n        return;\n      }\n\n      // Get slide + index.\n      let slide;\n      let index;\n\n      this.slides.forEach((s, i) => {\n        if (s.contains(event.target)) {\n          slide = s;\n          index = i + 1;\n        }\n      }, null);\n\n      // If there's a matching slide, go to it.\n      if (slide) {\n        this.goto(index, null, event);\n      }\n    };\n\n    // Resize Observer. Save so we can disconnect it during `destroy()`.\n    // Only init if browser supports it, else fallback to noop.\n    this.resizeObserver = { observe: () => {}, disconnect: () => {} };\n    if ('ResizeObserver' in window) {\n      this.resizeObserver = new ResizeObserver(this.resizeCallback.bind(this));\n    }\n\n    // Add all our listeners.\n    // Set timeout to avoid initial `goto` event triggering a scroll listener.\n    setTimeout(() => {\n      this.container.addEventListener('scroll', this.scrollListener, passive);\n      this.container.addEventListener('scroll', this.scrollEndListener, passive);\n      this.container.addEventListener('keydown', this.arrowKeyListener);\n      this.container.addEventListener('focusin', this.focusListener);\n      this.resizeObserver.observe(this.container);\n\n      // Done loading!\n      this.fireEvent('load');\n    }, 100);\n  }\n\n  /**\n   * Update the slider on load.\n   *\n   * @return {void}\n   */\n  hasLoaded() {\n    this.container.classList.add('has-loaded');\n  }\n\n  /**\n   * Update this slider (e.g., on resize). Basically just repositions the\n   * current slide.\n   *\n   * @return {void}\n   */\n  update() {\n    // Make sure we're still on the current slide.\n    this.goto(this.current, {\n      focus: false,\n      force: true,\n      ignoreCallbacks: true,\n      immediate: true,\n    });\n  }\n\n  /**\n   * Destroy this slider. Stop any active transitions, remove its event\n   * listeners, and delete it from our internal array of slider instances.\n   *\n   * @return {void}\n   */\n  destroy() {\n    // Stop running transitions, event listeners, etc.\n    this.stopTransition();\n    this.container.removeEventListener('scroll', this.scrollListener);\n    this.container.removeEventListener('scroll', this.scrollEndListener);\n    this.container.removeEventListener('keydown', this.arrowKeyListener);\n    this.resizeObserver.disconnect();\n\n    // Reset callbacks.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const eventName in this.callbacks) {\n      if (hasOwnProperty(this.callbacks, eventName)) {\n        this.callbacks[eventName] = [];\n      }\n    }\n\n    // Remove references to this slider.\n    delete this.container.SnapSlider;\n    delete window._SnapSliders[this.id];\n  }\n\n  /**\n   * Reset this slider (e.g., after adding or removing a slide).\n   *\n   * See `init()` for a full breakdown of `options`.\n   *\n   * @param  {Object}  options\n   * @return {void}\n   */\n  reset(options = {}) {\n    // Copy initial options.\n    const initialOptions = this.options;\n\n    // Remove initial callbacks to avoid duplicating them.\n    delete initialOptions.on;\n\n    // Don't let people reset critical options during reset (e.g., slider ID).\n    delete options.container;\n    delete options.id;\n\n    // Re-initialize this slider with initial options + overrides.\n    this.init(this.container, { ...initialOptions, ...options });\n  }\n\n  /**\n   * Handle resize observer events.\n   *\n   * @return {void}\n   */\n  resizeCallback() {\n    this.update();\n  }\n\n  /**\n   * When an event happens, fire all the callback functions for that event.\n   *\n   * @param  {String}   eventName\n   * @param  {Event}    event\n   * @param  {Object}   options\n   * @param  {Boolean}  options.focus\n   * @param  {Boolean}  options.ignoreCallbacks\n   * @return {void}\n   */\n  fireEvent(eventName, event, options = {}) {\n    // Ignore invalid events.\n    if (!hasOwnProperty(this.callbacks, eventName)) {\n      return;\n    }\n\n    // Fill default options.\n    options = {\n      // By default, focus the slide we're going to.\n      focus: true,\n      // Ignore custom callbacks for events.\n      ignoreCallbacks: false,\n      ...options,\n    };\n\n    // Required: Update slider attributes on load.\n    if (eventName === 'load') {\n      this.hasLoaded();\n    }\n\n    // Required: Update buttons and slides on every change.\n    if (eventName === 'change') {\n      this.updateButtons();\n      this.updateSlides();\n    }\n\n    // Allow focus events to be ignored.\n    if (options.focus) {\n      this.handleFocus(eventName, event);\n    }\n\n    // Allow callbacks to be ignored.\n    if (options.ignoreCallbacks) {\n      return;\n    }\n\n    // Fallback object for `null` events.\n    event = event || {};\n\n    // Include more granular event types for easier callbacks.\n    const events = [eventName];\n\n    if (hasOwnProperty(this.callbacks, `${eventName}.${event.type}`)) {\n      events.push(`${eventName}.${event.type}`);\n    }\n\n    // Fire all the callbacks for each event.\n    events.forEach((name) => {\n      this.callbacks[name].forEach((callback) => {\n        if (typeof callback === 'function') {\n          callback(this, event);\n        }\n      });\n    });\n  }\n\n  /**\n   * Handle focus events differently depending on whether we're manually\n   * triggering changes or passively scrolling.\n   *\n   * @param  {String}   eventName\n   * @param  {Event}    event\n   * @return {void}\n   */\n  handleFocus(eventName, event) {\n    // Only handle focus for manually triggered changes (e.g., clicks and key presses).\n    // Ignore passive scrolling to avoid mistakenly hijacking someone's focus.\n    if (!this.transition) {\n      return;\n    }\n\n    // Only focus the slide if we're NOT clicking a prev/next button.\n    if (event && eventName === 'change') {\n      // Did we click a button?\n      const button = event.target.closest('[data-snap-slider-goto]');\n      const { index } = SnapSlider.getButtonTarget(button);\n\n      // If we clicked a relative button, get out.\n      if (SnapSlider.isRelative(index)) {\n        return;\n      }\n    }\n\n    // If we're only transitioning one slide over, focus immediately on change.\n    if (this.transition.diff <= 1 && eventName === 'change') {\n      this.getCurrentSlide().focus({ preventScroll: true });\n    }\n\n    // If we're transitioning across multiple slides, wait until the scroll ends to focus.\n    // Otherwise, we'll cause the scroll to flicker.\n    if (this.transition.diff > 1 && eventName === 'scroll.end') {\n      // Only focus the slide if we haven't already focused on another\n      // element during the transition.\n      if (!document.activeElement\n        || document.activeElement === document.body\n        || document.activeElement.closest('[data-snap-slider-goto]')) {\n        this.getCurrentSlide().focus({ preventScroll: true });\n      }\n    }\n  }\n\n  /**\n   * Add callbacks to fire on specific events.\n   *\n   * @param  {String}    event     Event name.\n   * @param  {Function}  callback  Function w/ slider and event params (e.g., `fn(slider, event)`).\n   * @return {void}\n   */\n  on(event, callback) {\n    // Ignore invalid events.\n    if (!hasOwnProperty(this.callbacks, event)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n🚫 Whoops! Snap Slider can't add events for \"${event}\".\\n\n📝 Please make sure your event matches one of the ones in this list:\\n\\n`, Object.keys(this.callbacks), '\\n\\n');\n      }\n      return;\n    }\n\n    // Ignore invalid callbacks.\n    if (typeof callback !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        console.log(`\n  🚫 Whoops! Snap Slider can only add functions as callbacks.\\n\n  👀 It looks like you passed a \"${typeof callback}\" instead.\\n\\n`, callback, '\\n\\n');\n      }\n      return;\n    }\n\n    // Add the callback for our event.\n    this.callbacks[event].push(callback);\n  }\n\n  /**\n   * Log that we couldn't find the element you're looking for.\n   *\n   * @param  {mixed}  element\n   * @return {void}\n   */\n  static notFound(element) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(`\n😢 Oh no! Snap Slider couldn't find a slider for \"${element}\".\\n\n-------------------------------------------------------------------------------------------\nℹ️ NOTE: Make sure the elements you're trying to debug have a \\`data-snap-slider\\` attribute.\n-------------------------------------------------------------------------------------------\\n\\n`);\n    }\n  }\n\n  /**\n   * Get the `SnapSlider` object for a slider based on its ID.\n   *\n   * @param  {String}      id\n   * @return {SnapSlider}\n   */\n  static get(id) {\n    return window._SnapSliders[id];\n  }\n\n  /**\n   * `console.log` info about a slider, its nav, or goto buttons.\n   *\n   * @param  {String|Element|Array} idOrElements\n   * @return {void}\n   */\n  static debug(idOrElements) {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-irregular-whitespace */\n      let elements = [];\n\n      // 1. Debug all sliders by default.\n      if (arguments.length === 0) {\n        idOrElements = '[data-snap-slider]';\n      }\n\n      // 2. Debug a slider by its ID.\n      if (typeof idOrElements === 'string'\n        && hasOwnProperty(window._SnapSliders, idOrElements)) {\n        idOrElements = `[data-snap-slider=\"${idOrElements}\"]`;\n      }\n\n      // 3. Debug slider elements.\n      elements = getElements(idOrElements);\n\n      if (!elements.length) {\n        SnapSlider.notFound(idOrElements);\n        return;\n      }\n\n      // Debug all the things!\n      elements.forEach((el, i) => {\n        // What are we debugging? Is this a button, nav, or container?\n        const button = el.closest('[data-snap-slider-goto]');\n        const nav = el.closest('[data-snap-slider-nav]');\n        const container = el.closest('[data-snap-slider]');\n\n        // If we're debugging more than one element at a time,\n        // add the index # to each section heading.\n        const num = elements.length > 1 ? `#${i + 1} ` : '';\n\n        // 2a. Buttons\n        if (button) {\n          // Get details for the target slider & slide.\n          const target = SnapSlider.getButtonTarget(button);\n          const slider = window._SnapSliders[target.sliderID];\n\n          // Make sure slide index is valid.\n          const { index } = target;\n          const slideIndex = SnapSlider.isValidIndex(index)\n            ? `\"${index}\"`\n            : `🚫 \"${index}\" - Yikes! This index is invalid.\\n\\nUse a positive number instead, or one of the following aliases:\\n\n  ${['first', 'middle', 'last', 'prev', 'next'].map((a) => `• ${a}`).join('\\n')}`;\n\n          // \"We couldn't find anything.\"\n          const sliderID = target.sliderID\n            ? `\"${target.sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your button is inside a \\`data-snap-slider-nav\\` element, or...\n  • Include the slider ID you want to target in your \\`data-snap-slider-goto\\` attribute.\n      ◦ For example, \\`data-snap-slider-goto=\"example-slider:${target.index || 'prev'}\"\\`.`;\n\n          let sliderContainer = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your slider ID is correct (👆).\n  • Make sure your slider has the same ID in its \\`data-snap-slider\\` attribute.\n      ◦ For example, \\`data-snap-slider=\"example-slider\"\\`.`;\n          let slideIndexNumber = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your index is valid (👆).\n  • Make sure a slide actually exists at that index (👇).`;\n          let slide = `🤷‍♀️ We couldn't find any.\\n\n  • Double check that your index is valid (👆).\n  • Make sure a slide actually exists at that index.\n  • Make sure your slider recognizes the slide element as a slide.`;\n\n          // We found it!\n          if (slider && slider.container) {\n            sliderContainer = slider.container;\n            slideIndexNumber = slider.getIndexNumber(index);\n            slide = slider.getSlide(index);\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🕹 Button ${num}`,\n            description: button,\n            groups: [\n              {\n                heading: '1. What slider is this button targeting?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Element', description: sliderContainer },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. Which slide will it go to?',\n                items: [\n                  { heading: 'Slide Index', description: slideIndex },\n                  { heading: 'Slide Index (Number)', description: slideIndexNumber },\n                  { heading: 'Slide Element', description: slide },\n                ],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        // 2b. Navigation\n        if (nav) {\n          // Get details for the target slider\n          let sliderID = nav.getAttribute('data-snap-slider-nav');\n          const slider = window._SnapSliders[sliderID];\n          let buttons = qsa('[data-snap-slider-goto]', nav);\n\n          // \"We couldn't find anything.\"\n          sliderID = sliderID\n            ? `\"${sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Include the slider ID you want to target in your \\`data-snap-slider-nav\\` attribute.\n      ◦ For example, \\`data-snap-slider-nav=\"example-slider\"\\`.`;\n\n          let sliderContainer = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure the ID in your container's \\`data-snap-slider\\` attribute and the ID in your nav's \\`data-snap-slider-nav\\` attribute both match.`;\n\n          if (!buttons.length) {\n            buttons = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your buttons have a \\`data-snap-slider-goto\\` attribute.`;\n          }\n\n          // We found it!\n          if (slider && slider.container) {\n            sliderContainer = slider.container;\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🗺 Navigation ${num}`,\n            description: nav,\n            groups: [\n              {\n                heading: '1. What slider is this nav targeting?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Element', description: sliderContainer },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. What buttons are in this nav?',\n                items: [{ heading: 'Buttons', description: buttons }],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        // 2c. Containers (aka sliders)\n        if (container) {\n          // Get details for the slider.\n          let sliderID = container.getAttribute('data-snap-slider');\n          const slider = window._SnapSliders[sliderID];\n          let navs = qsa(`[data-snap-slider-nav=\"${sliderID}\"]`);\n          let buttons = slider ? slider.getButtons() : [];\n\n          // \"We couldn't find anything.\"\n          sliderID = sliderID\n            ? `\"${sliderID}\"`\n            : `🤷‍♀️ We couldn't find any.\\n\n  • Include the slider ID you want in your \\`data-snap-slider\\` attribute.\n      ◦ For example, \\`data-snap-slider=\"example-slider\"\\`.`;\n\n          if (!navs.length) {\n            navs = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure the ID in your container's \\`data-snap-slider\\` attribute and the ID in your nav's \\`data-snap-slider-nav\\` attribute both match.`;\n          }\n\n          if (!buttons.length) {\n            buttons = `🤷‍♀️ We couldn't find any.\\n\n  • Make sure your button is inside a \\`data-snap-slider-nav\\` element, or...\n  • Include the slider ID you want to target in your \\`data-snap-slider-goto\\` attribute.\n      ◦ For example, \\`data-snap-slider-goto=\"example-slider:prev\"\\`.`;\n          }\n\n          // Log 'em.\n          return logger.section({\n            heading: `🥨 Slider ${num}`,\n            description: container,\n            groups: [\n              {\n                heading: '1. What slider is this?',\n                items: [\n                  { heading: 'Slider ID', description: sliderID },\n                  { heading: 'Slider Object', description: slider || \"🤷‍♀️ We couldn't find any.\" },\n                ],\n              },\n              {\n                heading: '2. What navs target this slider?',\n                items: [{ heading: 'Navs', description: navs }],\n              },\n              {\n                heading: '3. What buttons target this slider?',\n                items: [{ heading: 'Buttons', description: buttons }],\n              },\n            ],\n            collapsed: true,\n          });\n        }\n\n        return SnapSlider.notFound(idOrElements);\n      });\n      /* eslint-enable no-irregular-whitespace */\n    }\n  }\n}\n\n// Keep track of all the sliders on the page to reference.\nwindow._SnapSliders = [];\n\n// Make the constructor globally accessible.\nwindow.SnapSlider = SnapSlider;\n\n// If jQuery exists, integrate.\nif (typeof $ !== 'undefined') {\n  // eslint-disable-next-line no-undef, func-names\n  $.fn.snapSlider = function (options) {\n    return new SnapSlider(this, options);\n  };\n}\n\n// Auto-init once the DOM is ready.\nonReady(() => {\n  // Init polyfills.\n  elementClosest(window);\n  smoothscroll.polyfill();\n\n  // Initialize all sliders with data attributes.\n  qsa('[data-snap-slider]').forEach((el) => new SnapSlider(el));\n\n  // Setup click events for *all* nav elements.\n  on('body', 'click', '[data-snap-slider-goto]', SnapSlider.handleGoto);\n});\n\nexport default SnapSlider;\n","import hasOwnProperty from './hasOwnProperty';\n\n/**\n * Get a computed style for some element.\n * @param  {Element}  el\n * @param  {String}   prop\n * @return {String}\n */\nexport default function getStyle(el, prop) {\n  const style = window.getComputedStyle(el);\n\n  // Ignore mmissing elements or props\n  if (!style || !hasOwnProperty(style, prop)) {\n    return '';\n  }\n\n  return style[prop];\n}\n","/**\n * Get an attribute for the closest element with it.\n * @param  {Element}  el\n * @param  {String}  attr\n * @return {String}\n */\nexport default function getClosestAttribute(el, attr) {\n  // Ignore missing elements\n  if (!el) {\n    return '';\n  }\n\n  // Find the closest element with a mattring attribute\n  el = el.closest(`[${attr}]`);\n\n  // If we found a match, return the attribute, otherwise\n  // return an empty string.\n  return el ? el.getAttribute(attr) : '';\n}\n","/**\n * Wait to run a function on DOMContentLoaded, or fire immediately if the\n * event has already fired.\n * @param  {Function} fn\n * @return {void}\n */\nexport default function onReady(fn) {\n  if (document.readyState !== 'loading') {\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', fn);\n  }\n}\n","/* eslint-disable consistent-return, func-names, no-var, prefer-arrow-callback, vars-on-top */\n\n/**\n * Plain JavaScript event delegation. Add a handler for whenever an element's\n * children trigger a specified event.\n * @see https://bdadam.com/blog/plain-javascript-event-delegation.html\n * @param  {String}    parentSelector\n * @param  {String}    eventName\n * @param  {String}    childSelector\n * @param  {Function}  fn\n * @return {Boolean}\n */\nexport default function on(parentSelector, eventName, childSelector, fn) {\n  var parent = document.querySelector(parentSelector);\n\n  if (!parent) {\n    return false;\n  }\n\n  parent.addEventListener(eventName, function (event) {\n    var possibleTargets = parent.querySelectorAll(childSelector);\n    var target = event.target;\n\n    for (var i = 0, l = possibleTargets.length; i < l; i += 1) {\n      var el = target;\n      var p = possibleTargets[i];\n\n      while (el && el !== parent) {\n        if (el === p) {\n          return fn.call(p, event);\n        }\n\n        el = el.parentNode;\n      }\n    }\n  });\n\n  return true;\n}\n\n// Example:\n// on('body', 'click', '.product', function(e) {\n//   console.log(e.target);\n// });\n","/**\n * Return a string of dashes.\n *\n * @param  {Number}  num\n * @param  {String}  char\n * @return {String}\n */\nexport default function dashes(num, char = '-') {\n  let str = '';\n\n  for (let i = 0; i < num; i += 1) {\n    str += char;\n  }\n\n  return str;\n}\n","/* eslint-disable indent */\n\n// Helpers\nimport dashes from '../helpers/dashes';\n\n/**\n * Get the substitution string for to format this value in a console.log.\n *\n * - %o = Object\n * - %d = Number (aka \"Digit\")\n * - %s = String\n * - %c = CSS\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions\n * @param  {mixed}   value\n * @return {String}\n */\nexport function getSubstitution(value) {\n  // Object\n  if (typeof value === 'object') {\n    return '%o';\n  }\n\n  // Number\n  if (typeof value === 'number') {\n    return '%d';\n  }\n\n  // When in doubt, assume everything else is a String.\n  return '%s';\n}\n\n/**\n * Log a full debug section.\n *\n * @param  {Object}  params\n * @param  {Object}  params.heading\n * @return {void}\n */\nexport function section(params) {\n  const {\n    heading,\n    description,\n    groups,\n    collapsed,\n  } = params;\n\n  // Allow groups to be collapsed.\n  const method = collapsed ? 'groupCollapsed' : 'group';\n\n  // HEADING\n  console.log(`%c\n┏━━${dashes(heading.length, '━')}━━┓\n┃  ${heading}  ┃\n┗━━${dashes(heading.length, '━')}━━┛`, 'font-size: 1.25em;', '\\n\\n',\n  description,\n  '\\n\\n');\n\n  // GROUPS\n  groups.forEach((group) => {\n    // Heading\n    console[method](`%c${group.heading}`, 'font-weight: bold;');\n\n    // Build up a single console.log for all the items in the group.\n    const args = [];\n    let content = '';\n\n    group.items.forEach((item) => {\n      // eslint-disable-next-line no-shadow\n      const { heading, description } = item;\n\n      // Heading\n      content += `\\n%c${getSubstitution(heading)}\\n`;\n      args.push('text-decoration: underline;', heading);\n\n      // Description\n      content += `\\n%c${getSubstitution(description)}\\n`;\n      args.push('text-decoration: none;', description);\n    });\n\n    // Log the items!\n    console.log(content, ...args);\n\n    // And end the group.\n    console.groupEnd();\n  });\n\n  // Add an empty line after the section.\n  console.log('\\n');\n}\n"],"sourceRoot":""}